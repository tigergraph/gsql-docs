= Creating a Loading Job
:pp: {plus}{plus}
:description: GSQL commands related to creating loading jobs.

After a graph schema has been created, the system is ready to load data into the graph store.
The GSQL language offers commands for data loading which perform many of the same data conversion, mapping, filtering, and merging operations that are found in enterprise ETL (Extract, Transform, and Load) systems.

The GSQL system can read structured or semi-structured data from text files.
The loading language syntax is geared towards tabular or JSON data, but conditional clauses and data manipulation functions allow for reading data that is structured in a more complex or irregular way.
For tabular data, each line in the data file contains a series of data values, separated by commas, tabs, spaces, or any other designated ASCII characters (only single character separators are supported).
A line should contain only data values and separators, without extra whitespace.
From a tabular view, each line of data is a row, and each row consists of a series of column values.

Loading data is a two-step process.

. First, a loading job is defined with a `CREATE LOADING JOB` statement.
. Next, the job is executed with a `RUN LOADING JOB` statement.

These two statements, and the components of the loading job, are detailed below.

The structure of a loading job will be presented hierarchically, top-down:

`CREATE LOADING JOB`, which may contain a set of DEFINE and LOAD statements

* `DEFINE` statements
* `LOAD` statements, which can have several clauses

[NOTE]
*All blank spaces are meaningful in string fields in CSV and JSON*.
Either pre-process your data files to remove extra spaces, or use GSQL's token processing functions `gsql_trim`, `gsql_ltrim`, and `gsql_rtrim` (<<_token_functions>>).

[NOTE]
User privileges for running loading jobs are treated as separate from privileges regarding reading and writing data to vertices and edges.
A user can create and run loading jobs even without the privileges to modify vertex and edge data.
For more information, see xref:tigergraph-server:user-access:access-control-model.adoc[].

== Loading job capabilities

TigerGraph's syntax for defining and running loading jobs offers several advantages:

* The TigerGraph platform can handle concurrent loading jobs, which can greatly increase throughput.
* The data file locations can be specified at compile time or at run time. Run-time settings override compile-time settings.
* A loading job definition can include several input files. When running the job, the user can choose to run only part of the job by specifying only some of the input files.
* Loading jobs can be monitored, aborted, and restarted.

=== Concurrent Loading

Among its several duties, the RESTPP component manages loading jobs. There can be multiple RESTPP-LOADER subcomponents, each of which can handle a loading job independently.  The maximum number of concurrent loading jobs is set by the configuration parameter `FileLoader.ReplicaNumber`.

Furthermore, if the TigerGraph graph is distributed (partitioned) across multiple machine nodes, each machine's RESTPP-LOADER(s) can be put into action. Each RESTPP-LOADER only reads local input data files, but the resulting graph data can be stored on any machine in the cluster.

[NOTE]
To maximize loading performance in a cluster, use at least two loaders per machine, and assign each loader approximately the same amount of data.

A concurrent-capable loading job can logically be separated into parts according to each file variable.  When a concurrent-capable loading job is compiled, a xref:tigergraph-server:API:built-in-endpoints.adoc#_run_a_loading_job[RESTPP endpoint] is generated for the loading job, which you can call to load data into your graph as an alternative to `RUN LOADING JOB`.

[NOTE]
====
Example loading jobs and data files for the `Book_Rating` schema defined earlier in the document are available in the `$(gadmin config get System.AppRoot)/document/examples` folder in your TigerGraph platform installation.
====

== `CREATE LOADING JOB`

The `CREATE LOADING JOB` statement is used to define a block of `DEFINE`, `LOAD`, and `DELETE` statements for loading data to or removing data from a particular graph.
The sequence of statements is enclosed in curly braces.
Each statement in the block, including the last one, should end with a semicolon.

.CREATE LOADING JOB syntax
[source,gsql]
----
CREATE LOADING JOB job_name FOR GRAPH Graph_Name {
   [zero or more DEFINE statements;] <1>
   [zero or more LOAD statements;] | [zero or more DELETE statements;] <2>
}
----

<1> While one loading job may define multiple data sources (files), keep the number below 100 for best performance.
<2> A loading job may contain either `LOAD` or `DELETE` statements but not both.
A loading job that includes both will be rejected when the `CREATE` statement is executed.

=== Loading data to global vertices and edges

The `CREATE VERTEX` and `CREATE EDGE` commands create global vertices and edges.
See the xref:defining-a-graph-schema.adoc#_create_vertex[CREATE VERTEX] and xref:defining-a-graph-schema.adoc#_create_edge[CREATE EDGE] pages for more detail.


Global vertex and edge type data is shared across all graphs, no matter which graph it is loaded to.
In other words, if `v1` and `e2` are of `GLOBAL` type, the data loaded in this loading job will be accessible in other graphs that use `v1` and `e2` vertices and edges.

To create a local vertex or edge, run a schema change job after a graph has already been created and use the `ADD VERTEX` or `ADD EDGE` command to add a vertex or edge to a single graph.
See xref:modifying-a-graph-schema.adoc#_global_vs_local_schema_changes[Global vs. local schema changes] for more information.

=== Example

.Loading Job Example
[source.wrap,gsql]
----
CREATE LOADING JOB job_1 FOR GRAPH Graph_1 {
   DEFINE FILENAME file1 = "/data/v1.csv"; <1>
   DEFINE FILENAME file2;

   LOAD file1 TO VERTEX v1 VALUES ($0, $1, $2);
   LOAD file2 TO EDGE e2 VALUES ($0, $1);
}

RUN LOADING JOB job1 USING file1="m1:/data/v1_1.csv", file2="m2:/data/e2.csv" <2>
----
<1> File path specified at compile time.
<2> Run-time specification will override path specified at compile time.

== `DROP JOB` statement

To drop (remove) a job, run `DROP JOB job_name`. The job will be removed from GSQL.
To drop all jobs, run either of the following commands:

[source,gsql]
----
DROP JOB ALL
DROP JOB *
----

The scope of `DROP JOB ALL` depends on the user's current scope.
If the user has set a working graph, then `DROP ALL` removes all the jobs for that graph.
If a superuser has set their scope to be global, then `DROP JOB ALL` removes all jobs across all graph spaces.

== `DEFINE` statements

A `DEFINE` statement is used to define a local variable or expression to be used by the subsequent `LOAD` statements in the loading job.

=== `DEFINE FILENAME`

The `DEFINE FILENAME` statement defines a filename variable.
The variable can then be used later in the `JOB` block by a `LOAD` statement to identify its data source.
Every concurrent loading job must have at least one `DEFINE FILENAME` statement.

[NOTE]
Having more than 100 file or folder sources will degrade performance.
Consider either consolidating sources or splitting your work into separate loading jobs.

[source,ebnf]
----
DEFINE FILENAME filevar ["=" filepath_string ];

filepath_string = (path | " all :" path | " any :" path | mach_aliases " :" path ["," mach_aliases ":" path ]*)
mach_aliases = name["|"name]*
----

==== Parameters

`filevar`:: The name of the filename variable.
`filepath_string`::
The `filevar` is optionally followed by a `filepath_string`, which tells the job where to find input data.
`filepath_string` is a string value and should start and end with double quotes.
+
There are four options for `filepath_string`:

* An absolute or relative path for either a file or a folder *on the machine where the job is run*.
If it is a folder, then the loader will attempt to load each non-hidden file in the folder.
If this path is not valid when `CREATE LOADING JOB` is executed, GSQL will report an error.
+
An absolute path may begin with the xref:tigergraph-server:gsql-shell:gsql-sessions.adoc[session parameter] `$sys.data_root`.
* An absolute or relative path for either a file or a folder *on all machines in the cluster*: If the path is prefixed with `all:`, then the loading job will attempt to run on every machine in the cluster which has a RESTPP component, and each machine will look locally for data at _path_. *If the path is invalid on any of the machines, the job will be aborted*.  Also, the session parameter `$sys.data_root` may not be used.
+
.`ALL:path` examples
[source,gsql]
----
"ALL:/data/graph.csv"
----

* An absolute or relative path for either a file or a folder *on any machine in the cluster*: If the path is prefixed with `any:`, then the loading job will attempt to run on every machine in the cluster which has a RESTPP component, and each machine will look locally for data at the specified path.
*If the path is invalid on any of the machines, those machines where the path is not valid are skipped.*
Also, the session parameter `$sys.data_root` may not be used.
+
.`ANY:path` examples
[source,gsql]
----
"ANY:/data/graph.csv"
----

* *A list of machine-specific paths*: A machine alias is a name such as m1, m2, etc. which is defined when the cluster configuration is set.
For this option, the `filepath_string` may include a list of paths, separated by commas.
If several machines have the same path, the paths can be grouped together by using a list of machine aliases, with the vertical bar "|" as a separator. The loading job will run on whichever machines are named; each RESTPP-LOADER will work on its local files.
+
.machine-specific path example
[source,gsql]
----
"m1:/data1.csv, m2|m3|m5:/data/data2.csv"
----


=== `DEFINE HEADER`

The `DEFINE HEADER` statement defines a sequence of column names for an input data file.
The first column name maps to the first column, the second column name maps to the second column, etc.

[source,ebnf]
----
DEFINE HEADER header_name = " column_name "[," column_name "]*;
----

=== `DEFINE INPUT_LINE_FILTER`

NOTE: This statement is not supported in a xref:tigergraph-server:data-loading:kafka-loader/index.adoc[Kafka loading job].

The `DEFINE INPUT_LINE_FILTER` statement defines a named Boolean expression whose value depends on column attributes from a row of input data.
When combined with a `USING reject_line_rule` clause in a `LOAD` statement, the filter determines whether an input line is ignored or not.

[source.wrap,ebnf]
----
DEFINE INPUT_LINE_FILTER filter_name = boolean_expression_using_column_variables;
----

include::partial$load-statement.adoc[]

== Attributes and attribute expressions

A `LOAD` statement processes each line of an input file, splitting each lin into a sequence of tokens.
Each destination clause provides a token-to-attribute mapping which defines how to construct a new vertex, an edge, or a temp table row instance (e.g., one data object).
The tokens can also be thought of as the column values in a table.
There are two ways to refer to a column, by position or by name.
Assuming a column has a name, either method may be used, and both methods may be used within one expression.

*By Position*: The columns (tokens) are numbered from left to right, starting with $0. The next column is $1, and so on.

*By Name*: Columns can be named, either through a header line in the input file, or through a `DEFINE HEADER` statement.
If a header line is used, then the first line of the input file should be structured like a data line, using the same separator characters, except that each column contains a column name string instead of a data value.Names are enclosed in double quotes, e.g. `$"age"`.

*Data file name:* $sys.file_name refers to the current input data file.

In a simple case, a token value is copied directly to an attribute.For example, in the following `LOAD` statement,

.Example: using $sys.file_name in an attribute expression

[source,gsql]
----
LOAD "xx/yy/a.csv" TO VERTEX Person VALUES ($0, $1, $sys.file_name)
----


* The `PRIMARY_ID` of a person vertex comes from column `$0` of the file "xx/yy/a.csv".
* The next attribute of a person vertex comes from column `$1`.
* The next attribute of a person vertex is given the value "xx/y/a.csv" (the filename itself).

[NOTE]
====
Users do not need to explicitly define a primary ID. Given the attributes, one will be selected as the primary key.
====

=== Cumulative loading

A basic principle in the GSQL Loader is cumulative loading. Cumulative loading means that a particular data object might be written to (i.e., loaded) multiple times, and the result of the multiple loads may depend on the full sequence of writes. This usually means that If a data line provides a valid data object, and the `WHERE` clause and `OPTION` clause are satisfied, then the data object is loaded.

* *Valid input*: For each input data line, each destination clause constructs one or more new data objects. To be a *valid data object,* it must have an ID value of the correct type, have correctly typed attribute values, and satisfy the optional `WHERE` clause. If the data object is not valid, the object is rejected (skipped) and counted as an error in the log file. The rules for invalid attributes values are summarized below:

. `UINT`: Any non-digit character. (Out-of-range values cause overflow instead of rejection)
. `INT`: Any non-digit or non-sign character. (Out-of-range values cause overflow instead of rejection)
. `FLOAT` and `DOUBLE`: Any wrong format
. `STRING`, `FIXED_BINARY`: N/A
. `DATETIME`: Wrong format, invalid date time, or out of range.
. `BOOL`: Any value not listed later.
. Complex type: Depends on the field type or element type. Any invalid field (in `UDT`), element (in `LIST` or `SET`), key or value (in `MAP`) causes rejection.

* *New data objects:* If a valid data object has a new ID value, then the data object is added to the graph store.  Any attributes which are missing are assigned the default value for that data type or for that attribute.
* *Overwriting existing data objects*: If a valid data object has an ID value for an existing object, then the new object overwrites the existing data object, with the following clarifications and exceptions:

. The attribute values of the new object overwrite the attribute values of the existing data object.
. *Missing tokens*: If a token is missing from the input line so that the generated attribute is missing, then that attribute retains its previous value.

[WARNING]
====
A STRING token is never considered missing; if there are no characters, then the string is the empty string
====

* *Skipping an attribute*: A `LOAD` statement can specify that a particular attribute should *not* be loaded by using the special character _ (underscore) as its attribute expression (attr_expr).
You can not skip the primary key attributes for vertices or discriminator attributes for edges.

For example, the following statement skips the next-to-last attribute.
This technique is used when it is known that the input data file does not contain data for every attribute.

[source,gsql]
----
LOAD TO VERTEX Person VALUES ($0, $1, _, $2)
----

. If the load operation is creating a new vertex or edge, then the skipped attribute will be assigned the default value.
. If the load operation is overwriting an existing vertex or edge, then the skipped attribute will retain its existing value.

=== More complex attribute expressions

An attribute expression may use column tokens (e.g., `$0`), literals (constant numeric or string values), any of the built-in loader token functions, or a user-defined token function. Attribute expressions may *not* contain mathematical or boolean operators (such as `+`, `*`, `AND`). The rules for attribute expressions are the same as those for id expressions, but an attribute expression can additionally use a reducer function:

* _id_expr_ := $column_number | $"column_name" | constant | $sys.file_name | token_function_name(_id_expr_ [, _id_expr_ ]*)
* _attr_expr_ := _id_expr_ | REDUCE(reducer_function_name(id __expr_))

Note that token functions can be nested, that is, a token function can be used as an input parameter for another token function. The built-in loader token/reducer functions and user-defined token functions are described in the section "Built-In Loader Token Functions".

The subsections below describe details about loading particular data types.

=== Loading a `DOUBLE` or `FLOAT` attribute

A floating point value has the basic format

[source,gsql]
----
[sign][digits].[digits](e|E)[sign][digits]
----

In the first case, the decimal point and following digits are required. In the second case, some digits are required (looking like an integer), and the following decimal point and digits are optional.

In both cases, the leading sign ("+" or "-") is optional. The exponent, using "e" or "E", is optional. Commas and extra spaces are not allowed.

.Examples of valid and invalid floating point values

[source,gsql]
----
# Valid floating point values
-198256.03
+16.
-.00036
7.14285e15
9.99E-22


# Invalid floating point values
-198,256.03
9.99 E-22
----


=== Loading a `DATETIME` attribute

When loading data into a `DATETIME` attribute, the GSQL loader automatically reads a string representation of DateTime information and convert it to internal DateTime representation.
The loader accepts any of the following string formats:

* `%Y-%m-%d %H:%M:%S` (e.g., 2011-02-03 01:02:03)
* `%Y/%m/%d %H:%M:%S` (e.g., 2011/02/03 01:02:03)
* `%Y-%m-%dT%H:%M:%S.000z` (e.g., 2011-02-03T01:02:03.123z, 123 will be ignored)
* `%Y-%m-%d` (only date, no time, e.g., 2011-02-03)
* `%Y/%m/%d` (only date, no time, e.g., 2011/02/03)
* Any integer value (Unix Epoch time, where Jan 1, 1970 at 00:00:00 is integer 0)

Format notation:

%Y is a 4-digit year. A 2-digit year is not a valid value.

%m and %s are a month (1 to 12) and a day (1 to 31), respectively.  Leading zeroes are optional.

%H, %M, %S are hours (0 to 23), minutes (0 to 59) and seconds (0 to 59), respectively.
Leading zeroes are optional.

When loading data, the loader checks whether the values of year, month, day, hour, minute, second are out of the valid range.
If any invalid value is present, e.g. '2010-13-05' or '2004-04-31 00:00:00', the attribute is invalid and the object (vertex or edge) is not created.

==== Load static `DATETIME` values

GSQL automatically converts correctly formatted strings in a data source file into `DATETIME` values during loading.
However, if you want to load static `DATETIME` values, you need to use `to_datetime()` to convert the strings into `DATETIME` values.

Once the strings have been converted to `DATETIME` values, you can use other `DATETIME` functions to modify the value you want loaded to the attribute.

For example, the following destination clause always loads the difference in the number of seconds (the first value minus the second value) between `"2020-01-01 00:00:00"` and `"2020-01-01 04:13:12"`, which is -2866392.

[.wrap,gsql]
----
TO EDGE date_time_edge VALUES ($"account_id", $"account_id",
        datetime_diff(to_datetime("2020-01-01 00:00:00"), to_datetime("2020-02-03 04:13:12"))
----

=== Loading a `BOOL` attribute

When loading data from CSV files the following values are accepted for BOOL attributes :

* True: `TRUE`,`True`,`true`,`1`
* False: `FALSE`,`False`,`false`,`0`

When loading data from JSON documents, the valid BOOL values are `true` and `false`.

=== Loading a User-defined type (UDT) attribute

To load a UDT attribute, state the name of the UDT type, followed by the list of attribute expressions for the UDT's fields, in parentheses.
See the example below.

.Load UDT example

[source,gsql]
----
include::appendix:example$test-schema/c_loadingjob_udt.gsql[]
----


[#_loading_a_list_or_set_attribute]
=== Loading a LIST or SET attribute

There are three methods to load a `LIST` or a `SET`.

The first method is to load multiple rows of data that share the same ID values and append the individual attribute values to form a collection of values.
The collections are formed incrementally by reading one value from each eligible data line and appending the new value into the collection.
When the loading job processes a line, it checks to see whether a vertex or edge with that id value(s) already exists or not.
If the id value(s) is new, then a new vertex or edge is created with a new list/set containing the single value.
If the id(s) has been used before, then the value from the new line is appended to the existing list/set.
Below shows an example:

[tabs]
====
Schema and loading job::
+
--

.Example: Cumulative loading of multiple rows to a SET/LIST
[source,gsql]
----
include::appendix:example$test-schema/c_loadingjob_list_set.gsql[]
----
--
Data file::
+
--
xref:attachment$list_set_vertex.csv[Download list_set_vertex.csv]

.list_set_vertex.csv
[source,gsql]
----
1,10
3,30
1,20
3,30
3,40
1,20
----
--
====


The job `load_set_list`  will load two `test_vertex` vertices because there are two unique id values in the data file.Vertex 1 has attribute values with `iset = [10,20]` and `ilist = [10,20,20]`.Vertex 3 has values `iset = [30,40]` and `ilist = [30, 30, 40]`.Note that a set doesn't contain duplicate values, while a list can contain duplicate values.

[WARNING]
====
Because GSQL loading is multi-threaded, the order of values loaded into a LIST might not match the input order.
====

If the input file contains multiple columns which should be all added to the LIST or SET, then a second method is available.Use the LIST() or SET() function as in the example below:

.Example: loading multiple columns to a SET/LIST
[source,gsql]
----
include::appendix:example$test-schema/c_loadingjob_set_list_multicolumn.gsql[]
----


The third method is to use the `SPLIT()` function to read a compound token and split it into a collection of elements, to form a `LIST` or `SET` collection.
The `SPLIT()` function takes two arguments: the column index and the element separator.
The element separator should be distinct from the separator throughout the whole file.Below shows an example:

[tabs]
====
Schema and loading job::
+
--
.Example: SET/LIST loading by SPLIT() example
[source,gsql]
----
include::appendix:example$test-schema/c_loading_job_split.gsql[]
----
--
Data file::
+
--
xref:attachment$split_list_set.csv[Download split_test_set.csv]

.split_list_set.csv
[source,text]
----
vid,names,numbers
v1,mike|tom|jack, 1 # 2 # 3
v2,john, 5 # 4 # 8
----
--
====

[WARNING]
====
The `SPLIT()` function cannot be used for UDT type elements.
====

[#_loading_a_map_attribute]
=== Loading a MAP attribute

There are three methods to load a `MAP`.

The first method is to load multiple rows of data that share the same ID values.
The maps are formed incrementally by reading one key-value pair from each eligible data line.
When the loading job processes a line, it checks to see whether a vertex or edge with that id value(s) already exists or not:

* If the ID value(s) is new, then a new vertex or edge is created with a new map containing the single key-value pair.
* If the ID(s) has been used before, then the loading job checks whether the key exists in the map or not.
** If the key doesn't exist in the map, the new key-value pair is inserted.
** If the key does exist, the newly loaded value replaces the old value.

[WARNING]
====
The loading order might not be the same as the order in the raw data.
If a data file contains multiple lines with the same ID and same key but different values, loading them together results in a nondeterministic final value for that key.
====

==== Load rows of key-value pairs by ID

To load rows of key-value pairs by ID, use the arrowhead `\->` to indicate the key-value pair relationship between the columns, and enclose them in parentheses.

For example, key-value pairs with tokens in column 2 as keys and tokens in column 3 as values is denoted by the following: `($1 \-> $2)`. 

.Loading a MAP by method 1: \-> separator
[source,gsql]
----
include::appendix:example$test-schema/c_loadingjob_map_1.gsql[]
----


==== Load key-value pairs in multiple columns with `MAP()`

The second method is to use the `MAP()` function.
If there are multiple key-value pairs among multiple columns, `MAP()` can load them together:

.Loading a MAP by method 2: MAP() function
[source,gsql]
----
include::appendix:example$test-schema/c_loadingjob_map_2.gsql[]
----


==== Load key-value pairs by splitting values in one column

The third method is to use the `SPLIT()` function.
The `SPLIT()` function can be used when the key-value pair is in one column and separated by a key-value separator, or multiple key-value pairs are in one column and separated by element separators and key-value separators.

`SPLIT()` has three parameters: The first is the column index, the second is the key-value separator, and the third is the element separator.
The third parameter is optional.
If one row of raw data only has one key-value pair, the third parameter can be skipped.
Below are the examples without and with the given element separator.


[tabs]
====
Data file 1::
+
--
xref:attachment$one_key_value.csv[Download one_key_value.csv]

.Example data with one key-value pair per line
[source,text]
----
vid,key_value
v1,1:mike
v2,2:tom
v1,3:lucy
----
--
Data file 2::
+
--
xref:attachment$multi_key_value.csv[Download multi_key_value.csv]

.Example data with multiple key-value pairs per line
[source,text]
----
vid,key_value_list
v1,1:mike#4:lin
v2,2:tom
v1,3:lucy#1:john#6:jack
----
--
Loading job::
+
--
.Loading a MAP by method 3: SPLIT() function
[source,gsql]
----
include::appendix:example$test-schema/c_loadingjob_map_split.gsql[]
----
--
====

[WARNING]
====
The `SPLIT()` function cannot be used for UDT type elements.
====

=== Loading composite key attributes

Loading a Composite Key for a vertex works no differently than normal loading. Simply load all the attributes as you would for a vertex with a single-attribute primary key. The primary key will automatically be constructed from the appropriate attributes.

When loading to an edge where either `TO_VERTEX` or `FROM_VERTEX` contains a composite key, the composite set of attributes must be enclosed in parentheses. See the example below.

.Example: loading composite key to vertex and edge
[source,gsql]
----
include::appendix:example$test-schema/c_loadingjob_compositekey.gsql[]
----


=== Loading Wildcard Type Edges

If an edge has been defined using a wildcard vertex type, a vertex type name must be specified, following the vertex id, in a `LOAD` statement for the edge. An example is shown below:

.Example: explicit vertex typing for an untyped edge
[source,gsql]
----
include::appendix:example$test-schema/c_loadingjob_wildcard.gsql[]
----


== Token functions

Token functions are functions in the DDL language that operate on tokens.Some may be used to construct attribute expressions and some may be used for conditional expressions in the `WHERE` clause.

To use a token function, replace the attribute in the destination clause of the `LOAD` statement with the function call.The arguments of the function can be a column from the `FILE` object.

[discrete]
==== Example

[source,gsql]
----
include::appendix:example$test-schema/c_loadingjob_tokenfunction.gsql[]
----

=== Token functions for attribute expressions

The following token functions can be used in an ID or attribute expression

[width="100%",cols="2,1,2",options="header",]
|===
|Function |Output type |Description
|gsql_reverse(_in_string_)
|string
|Returns a string with the
characters in the reverse order of the input string _in_string_.

|gsql_concat(_string1, string2,...,stringN_)
|string
|Returns a string
which is the concatenation of all the input strings.

|gsql_uuid_v4()
|string
|Returns a version-4 UUID.

|gsql_split_by_space(_in_string_)
|string
|Returns a modified version
of _in_string_, in which each space character is replaced with ASCII 30
(decimal).

|gsql_substring(_str_, _beginIndex_ [, _length_])
|string
|Returns the
substring beginning at _beginIndex_, having the given _length_.

|gsql_find(_str_, _substr_)
|int
|Returns the start index of the
substring within the string. If it is not found, then return -1.

|gsql_length(_str_)
|int
|Returns the length of the string.

|gsql_replace(_str_, _oldToken_, _newToken_ [, _max_])
|string
|Returns
the string resulting from replacing all matchings of _oldToken_ with
_newToken_ in the original string. If a _max_ count is provided, there
can only be up to that many replacements.

|gsql_regex_replace(_str_, _regex_, _replaceSubstr_)
|string
|Returns
the string resulting from replacing all substrings in the input string
that match the given _regex_ token with the substitute string.

|gsql_regex_match(_str_, _regex_)
|bool
|Returns true if the given
string token matches the given regex token and false otherwise.

|gsql_to_bool(_in_string_)
|bool
|Returns true if the _in_string_ is
either "t" or "true", with case-insensitive checking. Returns false
otherwise.

|gsql_to_uint(_in_string_)
|uint
a|* If _in_string_ is the string
representation of an unsigned int, the function returns that integer.
* If _in_string_ is the string representation of a non-negative float, the
function returns that number cast as an int.

|gsql_to_int(_in_string_)
|int
a|* If _in_string_ is the string
representation of an int, the function returns that integer.
* If _in_string_ is the string representation of a float, the function
returns that number cast as an int.

|gsql_ts_to_epoch_seconds(_timestamp_)
|uint
|Converts a timestamp in
canonical string format to Unix epoch time, which is the int number of
seconds since Jan. 1, 1970. Refer to the timestamp input format note
below.

|gsql_current_time_epoch(0)
|uint
|Returns the current time in Unix epoch seconds. *By
convention, the input parameter should be 0, but it is ignored.

a|
flatten (_column_to_be_split, group_separator, 1_)

flatten (_column_to_be_split, group_separator, sub_field_separator,
number_of_sub_fields_in_one_group_)

|
|See  <<_temp_table_and_flatten_functions>>.

a|
flatten_json_array (_$"array_name"_)

flatten_json_array (_$"array_name", $"sub_obj_1", $"sub_obj_2", ...,
$"sub_obj_n"_)
|
|See  <<_temp_table_and_flatten_functions>>.

a|
split(_column_to_be_split, element_separator_)

split(_column_to_be_split, key_value_separator, element _separator_)

|
a|
See <<_loading_a_list_or_set_attribute>>

See <<_loading_a_map_attribute>>

|gsql_upper(_in_string_)
|string
|Returns the input string in
upper-case.

|gsql_lower(_in_string_)
|string
|Returns the input string in
lower-case.

|gsql_trim(_in_string_)
|string
|Trims whitespace from the beginning
and end of the input string.

a|
gsql_ltrim(_in_string_)

gsql_rtrim(_in_string_)

|string
|Trims white space from either the beginning or the end of the
input string (Left or right).

|gsql_year(_timestamp_)
|int
|Returns 4-digit year from <<_timestamp_input_format,timestamp>>.

|_gsql_month(timestamp)_
|int
|Returns month (1-12) from <<_timestamp_input_format,timestamp>>.

|gsql_day(_timestamp_)
|int
|Returns day (1-31) from <<_timestamp_input_format,timestamp>>.

|gsql_year_epoch(_epoch_)
|int
|Returns 4-digit year from Unix epoch
time, which is the int number of seconds since Jan. 1, 1970.

|gsql_month_epoch(_epoch_)
|int
|Returns month (1-12) from Unix epoch
time, which is the int number of seconds since Jan. 1, 1970.

|gsql_day_epoch(_epoch_)
|int
|Returns day (1-31) from Unix epoch
time, which is the int number of seconds since Jan. 1, 1970.
|===

[#_timestamp_input_format]
==== Timestamp input format

The timestamp parameter should be in one of the following formats:

* `"%Y-%m-%d %H:%M:%S"`
* `"%Y/%m/%d %H:%M:%S"`
* `"%Y-%m-%dT%H:%M:%S.000z"`
** Text after the dot `.` is ignored


=== Token functions in the `WHERE` clause

See <<token-functions-in-where-clause>>.

=== User-defined token functions

Users can write their own token functions in C{pp} and install them in the GSQL system. To learn how to add a user-defined token function, see xref:add-token-function.adoc[].

=== Reducer functions

A reducer function aggregates multiple values of a non-ID attribute into one attribute value of a single vertex or edge.
Reducer functions are computed incrementally; that is, each time a new input token is applied, a new resulting value is computed.

To reduce and load aggregate data to an attribute, the attribute expression has the following form:

[source,gsql]
----
REDUCE(reducer_function (input_expr))
----

`reducer_function` is one of the functions in the following table.
`input_expr` can include non-reducer functions, but reducer functions cannot be nested.

Each reducer function is overloaded so that one function can be used for several data types:

* For primitive data types, the output type is the same as the type of the input expression `input_expr`.
* For `LIST`, `SET`, and `MAP` containers, the _input_expr_ type is one of the xref:attribute-data-types.adoc#_collection_types[allowed element types] for these containers.
The output is the entire container.

|===
| Function name | Return value

| `max(arg)`
| `INT`, `UINT`, `FLOAT`, `DOUBLE`: maximum of all `arg` values cumulatively received

| `min(arg)`
| `INT`, `UINT`, `FLOAT`, `DOUBLE`: minimum of all `arg` values cumulatively received

| `add(arg)`
a| * `INT`, `UINT`, `FLOAT`, `DOUBLE`: sum of all `arg` values cumulatively received
* `STRING`: concatenation of all arg values cumulatively received
* `LIST`, `SET` element: list/set of all `arg` values cumulatively received
* `MAP` (key -> value) pair: key-value dictionary of all key-value pair `arg` values cumulatively received:
+
--
** If the values in the key-value pairs are `INT` or `DOUBLE` types, the return values are the sums of all values by key.
** If the values in the key-value pairs are `STRING` type, the return values are concatenation of all values by key.
** If the values in the key-value pairs are `UDT` or `DATETIME` types, the return values are the last loaded value.
--
If loading into an existing vertex, the new loaded key-value pairs accumulate with the existing pairs in the same way.

| `and(arg)`
a| * `BOOL`: `AND` of all `arg` values cumulatively received
* `INT`, `UINT`: bitwise `AND` of all `arg` values cumulatively received

| `or(arg)`
a| * BOOL: `OR` of all `arg` values cumulatively received
* INT, UINT: bitwise `OR` of all `arg` values cumulatively received

| `overwrite(arg)`
a| * Non-container: `arg`
* `LIST`, `SET`: new list/set containing only `arg`

| `ignore_if_exists(arg)`
| Any: If an attribute value already exists, return(retain) the existing value.Otherwise, return(load) `arg` .
|===

[WARNING]
====
Each function supports a certain set of attribute types.
Calling a reducer function with an incompatible type crashes the service.
In order to prevent that, use the `WHERE` clause together with `IS NUMERIC` or other operators, functions, predicates for type checking if necessary.
====

[#_temp_table_and_flatten_functions]
== `TEMP_TABLE` and flatten functions

The keyword `TEMP_TABLE` triggers the use of a temporary data table which is used to store data generated by one `LOAD` statement, for use by a later `LOAD` statement.Earlier we introduced the syntax for loading data to a `TEMP_TABLE`:

.TEMP_TABLE Destination Clause
[source,gsql]
----
TO TEMP_TABLE table_name (id_name [, attr_name]*) VALUES (id_expr [, attr_expr]*)
    [WHERE conditions] [OPTION (options)]
----


This clause is designed to be used in conjunction with the `flatten` or `flatten_json_array` function in one of the `attr_expr` expressions.The flatten function splits a multi-value field into a set of records.Those records can first be stored in a temporary table, and then the temporary table can be loaded into vertices and/or edges.Only one flatten function is allowed in one temp table destination clause.

There are two versions of the flatten function: One parses single-level groups and the other parses two-level groups.There are also two versions of the flatten_json_array function: One splits an array of primitive values, and the other splits an array of JSON objects.

=== One-level flatten function

`flatten (column_to_be_split, separator, 1)` is used to parse a one-level group into individual elements.
An example is shown below:

The following loading job contains two `LOAD` statements. The first one loads input data to `Book` vertices and to a `TEMP_TABLE`. The second one loads the `TEMP_TABLE` data to `Genre` vertices and `Book_Genre` edges.


[tabs]
====
Schema and loading jobs::
+
--
.One-level Flatten Function loading (load_book_flatten1.gsql)
[source,gsql]
----
include::appendix:example$book_rating/c_loadingjob_flatten1.gsql[]
----
--
Data file::
+
--
xref:attachment$book1.dat[Download book1.dat]

.book1.dat
[source,gsql]
----
101|"Harry Potter and the Philosopher's Stone"|"fiction,fantasy,young adult"
102|"The Three-Body Problem"|"fiction,science fiction,Chinese"
----
--
====

Line 5 says that the third column (`$2`) of each input line should be split into separate tokens, with comma (`,`) as the separator.
Each token will have its own row in table `t1`.
The first column is labeled `bookcode` with value `$0` and the second column is `genre` with one of the `$2` tokens.
The contents of `TEMP_TABLE t1` are shown below:

|===
| bookcode | genre

| 101
| fiction

| 101
| fantasy

| 101
| young_adult

| 102
| fiction

| 102
| science_fiction

| 102
| Chinese
|===

Then, lines 8 to 10 say to read `TEMP_TABLE t1` and to do the following for each row:

* Create a `Genre` vertex for each new value of `genre`.
* Create a `Book_Genre` edge from `bookcode` to `genre`.  In this case, each row of `TEMP_TABLE t1` generates one `Book_Genre` edge.

The final graph will contain two `Book` vertices (101 and 102), five Genre vertices, and six `Book_Genre` edges.

.List of all Book_Genre edges after loading
[source,javascript]
----
{
  "results": [{"@@edgeSet": [
    {
      "from_type": "Book",
      "to_type": "Genre",
      "directed": false,
      "from_id": "101",
      "to_id": "fiction",
      "attributes": {},
      "e_type": "Book_Genre"
    },
    {
      "from_type": "Book",
      "to_type": "Genre",
      "directed": false,
      "from_id": "101",
      "to_id": "fantasy",
      "attributes": {},
      "e_type": "Book_Genre"
    },
    {
      "from_type": "Book",
      "to_type": "Genre",
      "directed": false,
      "from_id": "102",
      "to_id": "sciencevfiction",
      "attributes": {},
      "e_type": "Book_Genre"
    },
    {
      "from_type": "Book",
      "to_type": "Genre",
      "directed": false,
      "from_id": "101",
      "to_id": "young adult",
      "attributes": {},
      "e_type": "Book_Genre"
    },
    {
      "from_type": "Book",
      "to_type": "Genre",
      "directed": false,
      "from_id": "102",
      "to_id": "fiction",
      "attributes": {},
      "e_type": "Book_Genre"
    },
    {
      "from_type": "Book",
      "to_type": "Genre",
      "directed": false,
      "from_id": "102",
      "to_id": "Chinese",
      "attributes": {},
      "e_type": "Book_Genre"
    }
  ]}]
}
----


=== Two-level flatten function

flatten (_column_to_be_split, group_separator, sub_field_separator, number_of_sub_fields_in_one_group_) is used for parse a two-level group into individual elements. Each token in the main group may itself be a group, so there are two separators: one for the top level and one for the second level. An example is shown below.

.book2.dat

[source,gsql]
----
101|"Harry Potter and the Philosopher's Stone"|"FIC:fiction,FTS:fantasy,YA:young adult"
102|"The Three-Body Problem"|"FIC:fiction,SF:science fiction,CHN:Chinese"
----


The flatten function now has four parameters instead of three.  The additional parameter is used to record the genre_name in the Genre vertices.

.Two-level Flatten Function loading (book_flatten2_load.gsql)
[source,gsql]
----
include::appendix:example$book_rating/c_loadingjob_flatten2.gsql[]
----


In this example, in the genres column ($2), there are multiple groups, and each group has two sub-fields, genre_id and genre_name.
After running the loading job, the file book2.dat will be loaded into the TEMP_TABLE t2 as shown below.

|===
| bookcode | genre_id |

| 101
| FIC
| fiction

| 101
| FTS
| fantasy

| 101
| YA
| young adult

| 102
| FIC
| fiction

| 102
| SF
| science fiction

| 102
| CHN
| Chinese
|===

include::partial$flatten_json_array_primitive.adoc[]

include::partial$flatten_json_array_object.adoc[]

include::partial$flatten_json_object.adoc[]


[#_delete_statement]
== DELETE statement

In addition to loading data, a loading job can be used to perform the opposite operation: deleting vertices and edges, using the `DELETE` statement.

Just as a `LOAD` statement uses the tokens from each input line to set the id and attribute values of a vertex or edge to be created, a `DELETE` statement uses the tokens from each input line to specify the id value of the item(s) to be deleted.

There are four variations of the DELETE statement.The syntax of the four cases is shown below.

.DELETE VERTEX | EDGE Syntax
[source,gsql]
----
CREATE LOADING JOB abc FOR GRAPH Graph_Name {
  DEFINE FILENAME f;
  // Delete each vertex which has the given vertex type and primary id.
  DELETE VERTEX vertex_type_name (PRIMARY_ID id_expr) FROM f [WHERE condition] ;

  // Delete each edge which has the given edge type, source vertex id, target vertex id, and discriminator value if provided.
  DELETE EDGE edge_type_name (FROM id_expr, TO id_expr, DISCRIMINATOR (id_expr)) FROM f [WHERE condition] ;

  // Delete all edges which have the given edge type and source vertex id. (Destination vertex id is left open.)
  DELETE EDGE edge_type_name (FROM id_expr) FROM f [WHERE condition] ;

  // Delete all edges which have the given source vertex id. (Edge type and destination vertex id are left open.)
  DELETE EDGE * (FROM id_expr vertex_type_name) FROM f [WHERE condition] ;
}
----


An example using Book_Rating data is shown below:

.DELETE example
[source,gsql]
----
// Delete all user occupation edges if the user is in the new files, then load the new files
CREATE LOADING JOB clean_user_occupation FOR GRAPH Book_Rating {
  DEFINE FILENAME f;
  DELETE EDGE User_Occupation (FROM $0) FROM f;
}
CREATE LOADING JOB load_user_occupation FOR GRAPH Book_Rating {
  DEFINE FILENAME f;
  LOAD f TO EDGE User_Occupation VALUES ($0,$1);
}
RUN LOADING JOB clean_user_occupation USING f="./data/User_Occupation_update.dat"
RUN LOADING JOB load_user_occupation USING f="./data/User_Occupation_update.dat"
----

The following example shows how to delete edge instances that match the discriminator value from the data file:

[source.wrap,gsql]
----
DELETE EDGE Study_At (from $"person_id", to $"university_id",
    DISCRIMINATOR($"class_year", $"class_month")) from f;
----

[NOTE]
====
There is a separate DELETE statement in the GSQL Query Language. The query delete statement can leverage the query language's ability to explore the graph and to use complex conditions to determine which items to delete.
In contrast, the loading job delete statement requires that the id values of the items to be deleted must be specified in advance in an input file.
====