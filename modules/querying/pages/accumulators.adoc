= Accumulators
:description: This page describes the syntax and features of accumulators in the GSQL query language.
:stem: latexmath

Accumulators are special types of variables that accumulate information about the graph during its traversal and exploration.
Because they are a unique and important feature of the GSQL query language, we devote a separate section to their introduction, but additional detail on their usage will be covered in other sections, the xref:select-statement/sql-like-select-statement.adoc[`SELECT` Statement section] in particular.

This section covers the following subset of the EBNF language definitions:

.EBNF for accumulators
[source,ebnf]
----
accumDeclStmt :=
          accumType localAccumName ["=" constant]
                    ["," localAccumName ["=" constant]]*
        | accumType globalAccumName ["=" constant]
                    ["," globalAccumName ["=" constant]]*
localAccumName := "@"accumName;
globalAccumName := "@@"accumName;


accumType := "SumAccum" "<" ( INT | FLOAT | DOUBLE | STRING) ">"
       | "MaxAccum" "<" ( INT | FLOAT | DOUBLE ) ">"
       | "MinAccum" "<" ( INT | FLOAT | DOUBLE ) ">"
       | "AvgAccum"
       | "OrAccum"
       | "AndAccum"
       | "BitwiseOrAccum"
       | "BitwiseAndAccum"
       | "ListAccum" "<" elementType ">"
       | "SetAccum"  "<" elementType ">"
       | "BagAccum"  "<" elementType ">"
       | "MapAccum"  "<" elementType "," (baseType | accumType | tupleType) ">"
       | "HeapAccum" "<" tupleType ">" "(" simpleSize "," fieldName [ASC | DESC]
                                          ["," fieldName [ASC | DESC]]* ")"
       | "GroupByAccum" "<" elementType fieldName ["," elementType fieldName]* ,
		                     accumType fieldName ["," accumType fieldName]* ">"
       | "ArrayAccum" "<" accumName ">"
       | "DeviationAccum"
       | "DeviationPAccum"

elementType := baseType | tupleType

gAccumAccumStmt := globalAccumName "+=" expr

accumClause := ACCUM DMLSubStmtList

postAccumClause := "POST-ACCUM" DMLSubStmtList
----


There are a number of different types of accumulators, each providing specific accumulation functions.
Accumulators are declared to have one of three types of association: _global_, _vertex-attached_, or _edge_.

[NOTE]
====
Edge accumulators are supported starting with version 3.10, but only for single-hop paths in non-distributed queries.
Starting with version 4.1, edge accumulators do not have this restriction; they can be used with multi-hop paths and in distributed queries.
====
More technically, accumulators are mutable mutex (mutual exclusion) variables shared among all the graph computation threads exploring the graph within a given query.
To improve performance, the graph processing engine employs multithreaded processing.
Modification of accumulators is coordinated at run-time so the accumulation operator works correctly (i.e., mutually exclusively) across all threads.

This is particularly relevant in the `ACCUM` clause. During traversal of the graph, the selected set of edges or vertices is partitioned among a group of threads.
These threads have shared mutually exclusive access to the accumulators.

[#_declaration_of_accumulators]
== Declaration of Accumulators

* Global accumulators can be declared anywhere in the query.

* Vertex-attached accumulators can be declared anywhere in the query except for in a `FOREACH` loop or `WHILE` loop.

* Edge-attached accumulators can be declared anywhere in the query except for in a `FOREACH` loop or `WHILE` loop.

Accumulators are xref:querying:declaration-and-assignment-statements.adoc#_block_scoping[block-scoped] and can only be accessed in the block where they are declared.

* The name of a vertex-attached accumulator begins with a single `@`.

* The name of a edge-attached accumulator syntax differs from vertex-attached accumulator syntax by the leading `EDGE` keyword.

* The name of a global accumulator begins with `@@`.

.EBNF for Accumulator Declaration
[source.wrap,ebnf]
----
accumDeclStmt := globalAccumDeclStmt
              | localAccumDeclStmt

localAccumDeclStmt := vertexAccumDeclStmt
                    | edgeAccumDeclStmt

globalAccumDeclStmt := accumType globalAccum ["=" expr]
                       ["," globalAccumName ["=" expr]]*

vertexAccumDeclStmt := accumType localAccumName ["=" expr]
                       ["," vertexAccumName ["=" expr]]*
edgeAccumDeclStmt := accumType EDGE localAccumName ["=" expr]
                       ["," edgeAccumName ["=" expr]]*

localAccumName := "@"accumName;
globalAccumName := "@@"accumName;
----

== Vertex-attached Accumulators

Vertex-attached accumulators are mutable state variables that are attached to each vertex in the graph for the duration of the query's lifetime.
They act as run-time attributes of a vertex. They are shared, mutually exclusively, among all query processes.

Vertex-attached accumulators can be set to a value with the `=` operator.
Additionally, the operator `+=` can be used to update the state of the accumulator; the function of `+=` depends on the accumulator type.
Vertex-attached accumulators can only be accessed or updated (via `=` or `+=`) in an `ACCUM` or `POST-ACCUM` clause within a `SELECT` statement or by a `PRINT` statement.

In the example below, there are two accumulators attached to each vertex.
The initial value of an accumulator of a given type is predefined, however it can be changed at declaration as in the accumulator `@weight` below.
All vertex-attached accumulator names have a single leading at-sign `@`.

.Vertex-Attached Accumulators
[source,gsql]
----
SumAccum<INT>   @neighbors;
MaxAccum<FLOAT> @weight = 2.8;
----

If there is a graph with 10 vertices, then there is an instance of `@neighbors` and `@weight` for each vertex (hence 10 of each, and 20 total accumulator instances).
These are accessed via the dot operator on a vertex variable or a vertex alias (e.g., `v.@neighbor`).
The accumulator operator += only impacts the accumulator for the specific vertex being referenced.
A statement such as ``v1.@neighbors += 1``will only impact `v1` 's `@neighbors` and not the `@neighbors` for other vertices.


== Edge-attached Accumulators

[NOTE]
====
Currently, we only support edge attached accumulators in single GPR mode, a new internal engine framework for compiling non-distributed queries.
Please install the query with 'set single_gpr = true' or '-single' flag to use this feature.
====

Edge-attached accumulators are mutable state variables that are attached to each edge in the graph for the duration of the query's lifetime.
They act as run-time attributes of a edge.
They are shared, mutually exclusively, among all query processes.


Edge-attached accumulators can be set to a value with the `=` operator.
Additionally, the operator `\+=` can be used to update the state of the accumulator; the function of `+=` depends on the accumulator type.
Edge-attached accumulators can only be used (via `=` or `+=` ) in `ACCUM` or `WHERE` clauses within a `SELECT` statement

In the example below, there are two accumulators attached to each edge.
The initial value of an accumulator of a given type is predefined, however it can be changed at declaration as in the accumulator `@count` below.
All edge accumulator names have a single leading at-sign `@`.

[NOTE]
====
Edge-attached accumulator syntax differs from vertex-attached accumulator syntax by the leading `EDGE` keyword.

The only needs to be declared once per variable type. (Ex. `SumAccum<INT> EDGE @sum1, @sum2 = 1;`)
====

.Edge-Attached Accumulators. Note the 'EDGE` keyword.
[source,gsql]
----
SumAccum<INT> EDGE @count = 1;
MaxAccum<FLOAT> EDGE @max;
----

These are accessed via the dot operator on a edge variable or a edge alias (e.g., `e.@count`).
The accumulator operator `+=` only impacts the accumulator for the specific edge being referenced.
A statement such as `e1.@count += 1` will only impact `e1` 's `@count` and not the `@count` for other edges.

.Edge-Attached Accumulators in a Query
[source,gsql]
----
CREATE QUERY test() {
    SumAccum<INT> EDGE @count;
    R1 = SELECT t
        FROM Person:s -(KNOWS:e)- :t
        ACCUM
            e.@count += 1;
    R2 = SELECT t
        FROM Person:s -(KNOWS:e)- :t
        WHERE e.@count > 0;
    print R2;
}
----

[NOTE]
====
Edge accumulators cannot be used in `POST-ACCUM` clauses.
====

=== Known Issues

- Placing a vertex as a key and an edge accumulator as a value in a MapAccum can cause the query creation to fail.

- Attaching an ArrayAccum to an edge that is not connected to the target vertex can cause the query creation to fail.

- Edge accumulator feature is not supported with Distributed GPR mode with distributed calculation, and need data synchronization for any undirected edge types or reverse edge types.

== Global accumulators

A global accumulator is a single mutable accumulator that can be accessed or updated within a query. The names of global accumulators start with a double at-sign `@@`.

.Global Accumulators
[source,gsql]
----
SumAccum<INT>   @@totalNeighbors;
MaxAccum<FLOAT> @@entropy = 1.0;
----


Global accumulators can only be assigned (using the `=` operator) outside a `SELECT` block (i.e., not within an `ACCUM` or `POST-ACCUM` clause).
Global accumulators can be accessed or updated via the accumulate operator `+=` anywhere within a query, including inside a `SELECT` block.

The accumulation operation for global accumulators in an `ACCUM` clause executes once for each process. That is:

* If the `FROM` clause uses an edge-induced selection (introduced in Section "`SELECT` Statement"), the `ACCUM` clause executes one process for each edge in the selected edge set.
* If the `FROM` clause uses a vertex-induced selection (introduced in Section "`SELECT` Statement"), the `ACCUM` clause executes one process for each vertex in the selected vertex set.

Since global accumulators are shared in a mutually exclusive manner among processes, they behave very differently than a non-accumulator variable (see the xref:declaration-and-assignment-statements.adoc#_declaration_statements[Declaration Statements] section for more details) in an `ACCUM` clause.

Take the following code example. The global accumulator `@@globalRelationshipCount` is accumulated for every `Works_For` edge traversed since it is shared among processes. Conversely, `Relationship_Count` appears to have only been incremented once.

This is because a non-accumulator variable is not shared among processes.
Each process has its own separate unshared copy of `Relationship_Count` and increments the original value by one. (E.g., each process increments *Relationship_Count* from 0 to 1.) There is no accumulation and the final value is one.

=== Example
[tabs]
====
Query::
+
--
.Global Variable vs Global Accumulator
[source.wrap,gsql]
----
include::appendix:example$work_net/accum_global_var_vs_accum.gsql[]
----
--

Results::
+
--
.countEmploymentRelationship.json Results
[source,gsql]
----
GSQL > RUN QUERY count_employment_relationships()
include::appendix:example$work_net/accum_global_var_vs_accum_results.json[]
----
--
====


== Accumulator Types

The following are the accumulator types we currently support. Each type of accumulator supports one or more data types.

.EBNF for Accumulator Types
[source.wrap,ebnf]
----
accumType := "SumAccum" "<" ( INT | FLOAT | DOUBLE | STRING) ">"
           | "MaxAccum" "<" ( INT | FLOAT | DOUBLE ) ">"
           | "MinAccum" "<" ( INT | FLOAT | DOUBLE ) ">"
           | "AvgAccum"
           | "OrAccum"
           | "AndAccum"
           | "BitwiseOrAccum"
           | "BitwiseAndAccum"
           | "ListAccum" "<" type ">"
           | "SetAccum"  "<" elementType ">"
           | "BagAccum"  "<" elementType ">"
           | "MapAccum"  "<" elementType "," (baseType | accumType | tupleType) ">"
           | "HeapAccum" "<" tupleType ">" "(" simpleSize "," fieleName [ASC | DESC]
                               ["," fieldName [ASC | DESC]]* ")"
           | "GroupByAccum" "<" elementType fieldName ["," elementType fieldName]* ,
		                        accumType fieldName ["," accumType fieldName]* ">"
           | "ArrayAccum" "<" accumName ">"
           | "DeviationAccum"
           | "DeviationPAccum"

elementType := baseType | tupleType

gAccumAccumStmt := globaAccumName "+=" expr
----



The accumulators fall into two major groups :

* *Scalar Accumulators* store a single value:
 ** SumAccum
 ** MinAccum, MaxAccum
 ** AvgAccum
 ** AndAccum, OrAccum
 ** BitwiseAndAccum, BitwiseOrAccum
 ** DeviationAccum, DeviationPAccum
* *Collection Accumulators* store a set of values:
 ** ListAccum
 ** SetAccum
 ** BagAccum
 ** MapAccum
 ** ArrayAccum
 ** HeapAccum
 ** GroupByAccum

The details of each accumulator type are summarized in this table.  The Accumulation Operation column explains how the accumulator `exampleAccum` is updated when the statement `exampleAccum += newVal` is executed.

[CAUTION]
====
User should be careful when using `MinAccum`, `MaxAccum` and `SumAccum` with the generic type `vertex` and `edge` as the value might be `unknown`.

Additionally, users should add a check for an invalid vertex before using the vertex.

.Example
[source,gsql]
----
CREATE DISTRIBUTED QUERY localAccum_invalidVertex(){
    MinAccum<VERTEX> @a;
    SetAccum<VERTEX> @b;
    SetAccum<VERTEX> @c;

    Persons = SELECT src FROM Person:src
    ACCUM
        vertex d = src.@a,
        IF getvid(d) != -1 THEN
            d.@c += src.@b
        END
    LIMIT 3;

    PRINT Persons[Persons.@a, Persons.@b, Persons.@c];
}
----

====

Following the table are example queries for each accumulator type.

.Accumulator Types and Their Accumulation Behavior
[width="100%",cols="<34%,<33%,<33%",options="header",]
|===
|Accumulator type (Case Sensitive) |Default Initial Value |Accumulation
operation
|`SumAccum<INT>` |0 |Adds right operand to `SumAccum`.

|`SumAccum<FLOAT or DOUBLE>` |0.0 |Adds right operand to `SumAccum`.

|`SumAccum<STRING>` |Empty string |Concatenates `SumAccum` and right operand.

|`MaxAccum<INT>` |`INT_MIN` |Updates the value of `MaxAccum` to the greater between `MaxAccum` and right operand.

|`MaxAccum<FLOAT or DOUBLE>` |`FLOAT_MIN` or `DOUBLE_MIN` |Updates the value of `MaxAccum` to the greater between `MaxAccum` and right operand.

|`MaxAccum<STRING>` |Empty string |Updates the value of `MaxAccum` to the greater between `MaxAccum` and right operand according to UTF-8 lexicographical ordering.

|`MaxAccum<VERTEX>` |Vertex with internal ID `0` |Updates the value of `MaxAccum` to the vertex with greater internal ID between `MaxAccum` and right operand.

|`MaxAccum<tupleType>` |Default for each field of the tuple |Updates the value of `MaxAccum` to the greater between `MaxAccum` and right operand. `tupleType` is a user-defined sequence of
base types.
Ordering is hierarchical, using the leftmost field of the
tuple first, then the next field, and so on.

|`MinAccum<INT>` |`INT_MAX` |Updates the value of `MinAccum` to the lesser between `MinAccum` and right operand.

|`MinAccum<FLOAT or DOUBLE>` |`FLOAT_MAX` or `DOUBLE_MAX` |Updates the value of `MinAccum` to the lesser between `MinAccum` and right operand.

|`MinAccum<STRING>` |empty string |Updates the value of `MinAccum` to the lesser between `MinAccum` and right operand according to UTF-8 lexicographical ordering.

|`MinAccum<VERTEX>` |unknown |Updates the value of `MinAccum` to the vertex with lesser internal ID between `MinAccum` and right operand.

|`MinAccum<tupleType>` |Default for each field of the tuple |Updates the value of `MinAccum` to the lesser between `MinAccum` and right operand. `tupleType` is a user-defined sequence of
baseTypes. Ordering is hierarchical, using the leftmost field of the
tuple first, then the next field, and so on.

|`AvgAccum` |0.0 (double precision) |Updates `AvgAccum` to double precision average of right operand and all previous values accumulated to `AvgAccum`

|`DeviationAccum` |0.0 (double precision) |Updates `DeviationAccum` to double precision stdev of right operand and all previous values accumulated to `DeviationAccum`

|`DeviationPAccum` |0.0 (double precision) |Updates `DeviationPAccum` to double precision stdevp of right operand and all previous values accumulated to `DeviationPAccum`

|`AndAccum` |True |Updates `AndAccum` to boolean `AND` of right operand and `AndAccum`.

|`OrAccum` |False |Updates `OrAccum` to boolean `OR` of right operand and `AndAccum`.

|`BitwiseAndAccum` |-1 (INT) = 64-bit sequence of 1s |Updates `BitwiseAndAccum` to boolean `AND` of right operand and `BitwiseAndAccum`.

|`BitwiseOrAccum` |0 (INT) = 64-bit sequence of 0s |Updates `BitwiseOrAccum` to boolean `OR` of right operand and `BitwiseORAccum`.

a|
`ListAccum< type >`

|Empty list |Appends right operand to end of `ListAccum`.

a|
`SetAccum< type >`

|empty set |Updates `SetAccum` to union of right operand and `SetAccum`. right operand can be a single value or a set/bag.

a|
`BagAccum<type>`

|Empty bag |Updates `BagAccum` to union of right operand and `BagAccum`. Right operand can be a single value or a set/bag.

a|
`MapAccum< type, type >`

|Empty map |Adds or updates a key-value pair of `MapAccum`.

|`ArrayAccum< accumType >` |Empty list |See the <<ArrayAccum>> section below
for details.

a|
`HeapAccum< tuple >(heapSize, sortKey)`

|Empty heap |Inserts right operand into HeapAccum, maintaining the
heap in sorted order, according to the sort key(s) and size limit
declared for this `HeapAccum`.

|`GroupByAccum< _type [, type] , accumType [, accumType]*_ >` |Empty group
by map |Adds or updates a key:value pair GroupByAccum.
See Section
<<GroupByAccum>> for more details.
|===


=== SumAccum

The `SumAccum` type computes and stores the cumulative sum of numeric values or the cumulative concatenation of text values. The output of a `SumAccum` is a single numeric or string value. `SumAccum` variables operate on values of type `INT`, `UINT`, `FLOAT`, `DOUBLE`, or `STRING` only.

The `+=` operator updates the accumulator's state.
For `INT`, `FLOAT`, and `DOUBLE` types, `+= arg` performs a numeric addition, while for the `STRING` value type `+= arg` concatenates `arg` to the current value of the `SumAccum`.

==== Example

[tabs]
====
Query::
+
--
.SumAccum Example
[source,gsql]
----
include::appendix:example$minimal_net/accum_sumaccum.gsql[]
----
--

Results::
+
--
.sumAccumEx.json Result
[source,gsql]
----
GSQL > RUN QUERY sum_accum_ex()
include::appendix:example$minimal_net/accum_sumaccum_results.json[]
----
--
====


=== MinAccum / MaxAccum

The `MinAccum` and `MaxAccum` types calculate and store the cumulative minimum or the cumulative maximum of a series of values.
The output of a `MinAccum` or a `MaxAccum` is a single value of the type that was passed in.
`MinAccum` and `MaxAccum` variables operate on values of type `INT, UINT, FLOAT, DOUBLE, STRING, TUPLE`, and `VERTEX` (with optional specific vertex type) only.

For `MinAccum`, `+= arg` checks if the current value held is less than `arg` and stores the smaller of the two.
`MaxAccum` behaves the same, with the exception that it checks for and stores the greater instead of the lesser of the two.

==== Example
[tabs]
====
Query::
+
--
.MinAccum and MaxAccum Example
[source,gsql]
----
include::appendix:example$minimal_net/accum_minaccum.gsql[]
----
--

Results::
+
--
[source,gsql]
----
GSQL > RUN QUERY min_max_accum_Ex()
include::appendix:example$minimal_net/accum_minaccum_results.json[]
----
--
====



String minimum and maximum values are based on their UTF-8 codes, which is a multilingual superset of the ASCII codes.
Within ASCII, `a` is less than `z`, uppercase is less than lowercase, and digits are less than alphabetic characters.

`MinAccum` and `MaxAccum` operating on `VERTEX` types have a special comparison.
They do not compare vertex ids, but TigerGraph internal ids, which might not be in the same order as the external ids.
Comparing internal ids is much faster, so `MinAccum/MaxAccum<VERTEX>` provides an efficient way to compare and select vertices.
This is helpful for some graph algorithms that require the vertices to be numbered and sortable.
For example, the following query returns one post from each person. The returned vertex is not necessarily the vertex with the alphabetically largest id.

[tabs]
====
Query::
+
--
This query returns one random post vertex from each person
[source,gsql]
----
include::appendix:example$social_net/accum_maxaccum_vert.gsql[]
----
--

Results::
+
--
.minMaxAccumVertex.json Result
[source,gsql]
----
GSQL > RUN QUERY min_max_accum_vertex()
include::appendix:example$social_net/accum_maxaccum_vert_results.json[]
----
--
====


Tuple data types are treated as hierarchical structures, where the first field used for ordering is the leftmost one.
When a tuple is used as an element of a `MinAccum` or `MaxAccum`, tuple fields can be directly accessed from the accumulator.
For example, if we have the following tuple type and `MaxAccum` :

[source,text]
----
TYPEDEF TUPLE <FLOAT weight> Edge_Weight
MinAccum<EDGE_WEIGHT> @@acc_test;
----

Then the `weight` field of the tuple can be accessed directly from the `MinAccum` through the dot operator(`.`):

[source,cpp]
----
@@acc_test.weight // Will return the weight field value for the EDGE_WEIGHT
                 // type tuple stored in the MaxAccum
----

=== AvgAccum

The AvgAccum type calculates and stores the cumulative mean of a series of numeric values.
Internally, its state information includes the sum value of all inputs and a count of how many input values it has accumulated.
The output is the mean value; the sum and the count values are not accessible to the user.

The data type of an AvgAccum variable is not declared; all AvgAccum accumulators accept inputs of type `INT`, `UINT`, `FLOAT`, and `DOUBLE`.
The output is always `DOUBLE` type.

The `+= arg` operation updates the AvgAccum variable's state to be the mean of all the previous arguments along with the current argument.
The `= arg` operation clears the previously accumulated state and sets the new state to be `arg` with a count of one.

==== Example
[tabs]
====
Query::
+
--
.AvgAccum Example
[source,gsql]
----
include::appendix:example$minimal_net/accum_avgaccum.gsql[]
----
--

Results::
+
--
[source,gsql]
----
GSQL > RUN QUERY avg_accum_ex()
include::appendix:example$minimal_net/accum_avgaccum_results.json[]
----
--
====

=== DeviationAccum / DeviationPAccum

The DeviationAccum and DeviationPAccum type calculate and store the cumulative standard deviation of a series of numeric values.

DeviationAccum should be used when taking a sample of the population for an unbiased estimate. (Uses `N - 1` as the denominator for the standard deviation function.)

DeviationPAccum should be used when the standard variation of the entire population is being calculated

Like AvgAccum, data type of a DeviationAccum variable is not declared; all DeviationAccum accumulators accept inputs of type `INT`, `UINT`, `FLOAT`, and `DOUBLE`.
The output is always `DOUBLE` type.

The `+= arg` operation updates the DeviationAccum variable's state to be the `stdev` of all the previous arguments along with the current argument.
The `= arg` operation clears the previously accumulated state and sets the new state to accumulate a single value.

==== Example
[tabs]
====
Query::
+
--
.DeviationAccum Example
[source,gsql]
----
include::appendix:example$minimal_net/accum_deviationaccum.gsql[]
----
--

Results::
+
--
[source,gsql]
----
GSQL > RUN QUERY deviation_accum_ex()
include::appendix:example$minimal_net/accum_deviationaccum_results.json[]
----
--
====

=== AndAccum / OrAccum

The AndAccum and OrAccum types calculate and store the cumulative result of a series of boolean operations.
The output of an AndAccum or an OrAccum is a single boolean value (`TRUE` or `FALSE`). AndAccum and OrAccum variables operate on boolean values only.
The data type does not need to be declared.

For AndAccum, `+= arg` updates the state to be the logical `AND` between the current boolean state and `arg`.
OrAccum behaves the same, with the exception that it stores the result of a logical `OR` operation.

==== Example
[tabs]
====
Query::
+
--
.AndAccum and OrAccum Example
[source,gsql]
----
include::appendix:example$minimal_net/accum_oraccum.gsql[]
----
--

Results::
+
--
[source,gsql]
----
GSQL > RUN QUERY and_or_accum_ex()
include::appendix:example$minimal_net/accum_oraccum_results.json[]
----
--
====


[#_bitwiseandaccum_bitwiseoraccum]
=== BitwiseAndAccum / BitwiseOrAccum

The BitwiseAndAccum and BitwiseOrAccum types calculate and store the cumulative result of a series of bitwise boolean operations and store the resulting bit sequences.
The default length for both BitwiseAndAccum and BitwiseOrAccum is 64 bit.
You can specify the length of both types by appending the desired length in angle brackets``<>``.


Fundamental to understanding and using bitwise operations is the knowledge that integers are stored in base-2 representation as a 64-bit sequence of 1s and 0s.
"Bitwise" means that each bit is treated as a separate boolean value, with 1 representing true and 0 representing false.
Hence, an integer is equivalent to a sequence of boolean values.
Computing the Bitwise `AND` of two numbers A and B means computing the bit sequence C where the stem:[j_{th}] bit of C, denoted stem:[C_j], is equal to stem:[A_j] `AND` stem:[B_j].

==== Declaration

A bitwise accumulator has different declaration syntax depending on its length:

* When a bitwise accumulator length is less than or equal to 64 bit, it's assigned using one integer.
The integer is converted to a 64-bit sequence of 1s and 0s.
Overflow on the left is ignored.
* When a bitwise accumulator length is longer than 64 bit, it's assigned using an array of two integers.
Each integer is converted to a 64-bit sequence of 1s and 0s.
The integer in the second position will take up the first 64 bits from the right of the sequence, and the integer on the left will take up the remaining bits.
Any overflowing bits will be ignored.

For example, if you are declaring an 80-bit BitwiseAndAccum:

    @@bit80<80> = [123, 456]

456 represents the 64-bit sequence `0000….000111001000` (zeros omitted), and 123 represents the 64-bit sequence `0000000000…00001111011` (zeros omitted).

When the two integers are joined together, the 64-bit sequence on the right (456) takes up the 64 bits from the right.
The 64-bit sequence on the left (123) takes up the remaining 16 bits and the overflow on the left is ignored.

The resulting BitwiseAndAccum prints as below:

    0000000001111011 (16bits in total) 0000000...000111001000 (64bits in total)



==== Accumulation behavior

For BitwiseAndAccum, `+= arg` updates the accumulator's state to be the Bitwise `AND` of the current state and `arg`.
BitwiseOrAccum behaves the same, with the exception that it computes a Bitwise `OR`.

[CAUTION]
====
Bitwise Operations and Negative Integers

Most computer systems represent negative integers using "2's complement" format, where the uppermost bit has special significance. Operations that affect the uppermost bit are crossing the boundary between positive and negative numbers, and vice versa.
====

==== Functions
This is a list of methods of BitwiseAndAccum and BitwiseOrAccum.
If a method returns an `BitwiseAndAccum` or `BitwiseOrAccum`, it returns the same type as the instance that calls the method.

.Bitwise accumulator functions
|===
|Function |Return type |Accessor/Mutator |Description

|`.reset()`
|None.
|Mutator
|Sets all bits to 0.

|`.cardinality()`
|`INT`
|Accessor
|Returns the number of 1s.

|`.get( index )`
|`INT`
|Accessor
a|Returns the 1 or 0 at the provided index.

* `index`: `INT`.
The position of the bit value to return.

|`.set( )`
|None.
|Mutator
|Sets all bits to 1.

|`.set( index, value )`
|None.
|Mutator
a|Sets the bit at the provided index to the desire value.

* `index`:
`INT`. The position of the bit
* `value`:
`BOOL`.
The value of the bit.

|`.flip( index )`
|None.
|Mutator
|Flips the bit at the specified index.
If the bit is 0, changes it to 1 and vice versa.


|`.flip( fromIndex [, toIndex ] )`
|None.
|Mutator
|Flips the bits in the specified range.

|`.xor ( accum )`
|None.
|Mutator
|Compares two bitwise accumulators of the same length.
Returns a Bitwise accumulator whose every bit is the exclusive `OR` result between the two bitwise accumulators.

|`.and ( accum )`
|None.
|Mutator
|Compares two bitwise accumulators of the same length.
Returns a bitwise accumulator whose every bit is the `AND` result between the two bitwise accumulators.

|`.or ( accum )`
|None.
|Mutator
|Compares two bitwise accumulators of the same length.
Returns a Bitwise accumulator whose every bit is the `OR` result between the two bitwise accumulators.
|===



==== Example

[tabs]
====
Query::
+
--
[source,gsql]
----
include::appendix:example$minimal_net/accum_bitwise.gsql[]
----
--

Results::
+
--
[source,gsql]
----
GSQL > RUN QUERY bitwise_accum_ex()
include::appendix:example$minimal_net/accum_bitwise_results.json[]
----
--
====


[#_listaccum]
=== ListAccum

The ListAccum type maintains a sequential collection of elements.
The output of a ListAccum is a list of values in the order the elements were added.
The element type can be any base type or tuple.
Additionally, a ListAccum can contain a nested collection of type ListAccum.
Nesting of ListAccums is limited to a depth of three.

The `+= arg` operation appends `arg` to the end of the list.
In this case, `arg` may be either a single element or another ListAccum.

ListAccum supports two additional operations:

* `@list1 + @list2` creates a new ListAccum, which contains the elements of `@list1` followed by the elements of `@list2`.
The two ListAccums must have identical data types.

* `@list1 * @list2` (`STRING` data only) generates a new list of strings consisting of all permutations of an element of the first list followed by an element of the second list.

ListAccum also supports the following class functions.

[WARNING]
====
Functions that modify the ListAccum (mutator functions) can be used only under the following conditions:

* Mutator functions of global accumulators may only be used at the query-body level.
* Mutator functions of vertex-attached accumulators may only be used in a `POST-ACCUM` clause.
====

|===
| Function (T is the element type) | Return type | Accessor / Mutator | Description

| `.size()`
| `INT`
| Accessor
| Returns the number of elements in the list.

| `.contains( T _val_ )`
| `BOOL`
| Accessor
| Returns true if the list does contain `value`, and false if it doesn't.

| `.get( INT _idx_ )`
| T
| Accessor
| Returns the value at the given _index_ position in the list. The index begins at 0. If the index is out of bound (including any negative value), the default value of the element type is returned.

| `.clear()`
| `VOID`
| Mutator
| Clears the list so it becomes empty with size 0.

| `.update (INT _index,_ T _value_ )`
| `VOID`
| Mutator
| Assigns _value_ to the list element at position _index_.

|`.remove(INT _index_)`
|`VOID`
|Mutator
|Removes value at the specified index. If the index is invalid, the function will do nothing.

|`.removeOne(T _value_)`
|`VOID`
|Mutator
|Removes the first matching value. If there is no matching value, the function will do nothing.

|`.removeAll(T _value_)`
|`VOID`
|Mutator
|Removes all matching values. If there is no matching value, the function will do nothing.
|===

==== Examples
[tabs]
====
Query::
+
--
[source,gsql]
----
include::appendix:example$minimal_net/accum_listaccum.gsql[]
----
--

Results::
+
--
[source,gsql]
----
GSQL > RUN QUERY list_accum_ex()
include::appendix:example$minimal_net/accum_listaccum_results.json[]
----
--
====

[tabs]
====
Query::
+
--
.Example for update function on a global ListAccum
[source,gsql]
----
include::appendix:example$work_net/accum_global_listaccum.gsql[]
----
--

Results::
+
--
.Results in listAccumUpdateEx.json
[source,gsql]
----
GSQL > RUN QUERY list_accum_update_ex()
include::appendix:example$work_net/accum_global_listaccum_results.json[]
----
--
====

[tabs]
====
Query::
+
--
.Example for update function on a vertex-attached ListAccum
[source,gsql]
----
include::appendix:example$work_net/accum_vertex_listaccum.gsql[]
----
--

Results::
+
--
[source,gsql]
----
GSQL > RUN QUERY list_accum_update_ex2(["person1","person5"])
include::appendix:example$work_net/accum_vertex_listaccum_results.json[]
----
--
====


[#_setaccum]
=== SetAccum

The SetAccum type maintains a collection of unique elements.The output of a SetAccum is a list of elements in arbitrary order.
A SetAccum instance can contain values of one type.
The element type can be any base type or tuple.

For SetAccum, the `+= arg` operation adds a non-duplicate element or set of elements to the set.
If an element is already represented in the set, then the SetAccum state does not change.

SetAccum also can be used with the three canonical set operators: `UNION`, `INTERSECT`, and `MINUS` (see the xref:operators-and-expressions.adoc#_setbag_expression_and_operators[Set/Bag Expression and Operators] section for more details).

SetAccum also supports the following class functions.

[WARNING]
====
Functions that modify the SetAccum (mutator functions) can be used only under the following conditions:

* Mutator functions of global accumulators may only be used at the query-body level.
* Mutator functions of vertex-attached accumulators may only be used in a `POST-ACCUM` clause.
====

|===
| Function (T is the element type) | Return type | Accessor / Mutator | Description

| `size()`
| `INT`
| Accessor
| Returns the number of elements in the set.

| `contains( T value )`
| `BOOL`
| Accessor
| Returns true if the set contains `value`.
Returns false if the set doesn't contain `value`.

| `remove( T value )`
| `VOID`
| Mutator
| Removes `value` from the set.

| `clear()`
| `VOID`
| Mutator
| Clears the set so it becomes empty with size 0.
|===

==== Example
[tabs]
====
Query::
+
--
.SetAccum Example
[source,gsql]
----
# SetAccum Example
CREATE QUERY setAccumEx() FOR GRAPH Minimal_Net {

  SetAccum<INT> @@intSetAccum;
  SetAccum<STRING> @@stringSetAccum;

  @@intSetAccum += 5;
  @@intSetAccum.clear();

  @@intSetAccum += 4;
  @@intSetAccum += 11;
  @@intSetAccum += 1;
  @@intSetAccum += 11; # Sets do not store duplicates

  @@intSetAccum += (1,2,3,4); # Can create simple sets this way
  PRINT @@intSetAccum;
  @@intSetAccum.remove(2);
  PRINT @@intSetAccum AS RemovedVal2; # Demostrate remove.

  PRINT @@intSetAccum.contains(3);

  @@stringSetAccum += "Hello";
  @@stringSetAccum += "Hello";
  @@stringSetAccum += "There";
  @@stringSetAccum += "World";
  PRINT @@stringSetAccum;

  PRINT @@stringSetAccum.contains("Hello");
  PRINT @@stringSetAccum.size();
}
----
--

Results::
+
--
.setAccumEx.json Result
[source,gsql]
----
GSQL > RUN QUERY set_accum_ex()
{
  "error": false,
  "message": "",
  "version": {
    "edition": "developer",
    "schema": 0,
    "api": "v2"
  },
  "results": [ {"@@intSetAccum": [ 3, 2, 1, 11, 4 ]},
    {"@@intSetAccum.contains(3)": true},
    {"@@stringSetAccum": [ "World", "There", "Hello" ]},
    {"@@stringSetAccum.contains(Hello)": true},
    {"@@stringSetAccum.size()": 3}
  ]
}
----
--
====


[#_bagaccum]
=== BagAccum

The BagAccum type maintains a collection of elements with duplicated elements allowed.
The output of a BagAccum is a list of elements in arbitrary order.
A BagAccum instance can contain values of one type.
The element type can be any base type or tuple.

For BagAccum, the `+= arg` operation adds an element or bag of elements to the bag.

BagAccum also supports the `+` operator:

* `@bag1 + @bag2` creates a new BagAccum, which contains the elements of `@bag1` and the elements of `@bag2`. 
The two BagAccums must have identical data types.

BagAccum also supports the following class functions.

[WARNING]
====
Functions which modify the BagAccum (mutator functions) can be used only under the following conditions:

* Mutator functions of global accumulators may only be used at the query-body level.
* Mutator functions of vertex-attached accumulators may only be used in a `POST-ACCUM` clause.
====

|===
| Function (T is the element type) | Return type | Accessor / Mutator | Description

| `size()`
| `INT`
| Accessor
| Returns the number of elements in the bag.

| `contains( T value )`
| `BOOL`
| Accessor
| Returns true/false if the bag does/doesn't contain `value` .

| `clear()`
| `VOID`
| Mutator
| Clears the bag so it becomes empty with size 0.

| `remove( T value )`
| `VOID`
| Mutator
| Removes one instance of _value_ from the bag.

| `removeAll( T value )`
| `VOID`
| Mutator
| Removes all instances of the given value from the bag.
|===

==== Example
[tabs]
====
Query::
+
--
.BagAccum Example
[source,gsql]
----
include::appendix:example$minimal_net/accum_bagaccum.gsql[]
----
--

Results::
+
--
[source,gsql]
----
GSQL > RUN QUERY bag_accum_ex()
include::appendix:example$minimal_net/accum_bagaccum_results.json[]
----
--
====


[#_mapaccum]
=== MapAccum

The MapAccum type maintains a collection of (key -> value) pairs.
The output of a MapAccum is a set of key and value pairs in which the keys are unique.

The key type of a MapAccum can be all base types or tuples.
If the key type is `VERTEX`, then only the vertex's ID is stored and displayed.

The value type of a MapAccum can be all base types, tuples, or any type of accumulator, except for HeapAccum.

For MapAccum, the `+= (key->val)` operation adds a key-value element to the collection if the key is not yet used in the MapAccum.
If the MapAccum already contains the key, then the corresponding value is _accumulated_ to the current value, where the accumulation operation depends on the data type of the value:

* Strings are concatenated.
* Lists are appended.
* Numerical values are added.
* `DATETIME` and `ENUM` types are overwritten by the latest value.

MapAccum also supports the `+` operator, which combines two MapAccums:

* `@map1 + @map2` creates a new MapAccum, which contains the key-value pairs of `@map2` added to the key-value pairs of `@map1`.
* The values at the same key accumulates from the left side to the right side in the same way as in the accumulation operation.
* You can also use the `+=` operator to combine two MapAccums.
The behavior is identical.

The two MapAccums must have identical data types.

MapAccum also supports the following class functions.

[WARNING]
====
Functions that modify the MapAccum (mutator functions) can be used only under the following conditions:

* Mutator functions of global accumulators may only be used at the query-body level.
* Mutator functions of vertex-attached accumulators may only be used in a `POST-ACCUM` clause.
====

|===
| Function (`KEY` is the key type) | Return type | Accessor / Mutator | Description

| `.size()`
| `INT`
| Accessor
| Returns the number of elements in the map.

| `.containsKey( KEY key )`
| `BOOL`
| Accessor
| Returns true if the map does contain `key` and false if it doesn't.

| `.get( KEY key )`
| _value_ type
| Accessor
| Returns the value which the map associates with `key`.
If the map doesn't contain key, then the return value is undefined.

| `.clear()`
| `VOID`
| Mutator
| Clears the map so it becomes empty with size 0.

|`.remove( KEY key )`
|`VOID`
|Mutator
| Removes the key-value pair with the specified key. If there is no matching key, then the function will do nothing.
|===

==== Example
[tabs]
====
Query::
+
--
.MapAccum Example
[source,gsql]
----
include::appendix:example$minimal_net/accum_mapaccum.gsql[]
----
--

Results::
+
--
[source,gsql]
----
GSQL > RUN QUERY map_accum_ex()
include::appendix:example$minimal_net/accum_mapaccum_results.gsql[]
----
--
====


=== ArrayAccum

The ArrayAccum type maintains an array of accumulators. An array is a fixed-length sequence of elements, with direct access to elements by position.  The ArrayAccum has these particular characteristics:

* The elements are accumulators, not primitive or base data types. All accumulators, except HeapAccum, MapAccum, and GroupByAccum, can be used.
* An ArrayAccum instance can be multidimensional. There is no limit to the number of dimensions.
* The size can be set at run-time (dynamically).
* There are operators which update the entire array efficiently.

When an ArrayAccum is declared, the instance name should be followed by a pair of brackets for each dimension.  The brackets may either contain an integer constant to set the size of the array, or they may be empty. In that case, the size must be set with the reallocate function before the ArrayAccum can be used.

.ArrayAccum declaration example
[source,gsql]
----
ArrayAccum<SetAccum<STRING>> @@names[10];
ArrayAccum<SetAccum<INT>> @@ids[][];  // 2-dimensional, size to be determined
----



Because each element of an ArrayAccum itself is an accumulator, the operators =, +=, and + can be used in two contexts: accumulator-level and element-level.

==== *Element-level operations*

If @A is an ArrayAccum of length 6, then @A[0] and @A[5] refer to its first and last elements, respectively. Referring to an ArrayAccum element is like referring to an accumulator of that type.  For example, given the following definitions:

[source,text]
----
ArrayAccum<SumAccum<INT>> @@Sums[3];
ArrayAccum<ListAccum<STRING>> @@Lists[2];
----

then @@Sums[0], @@Sums[1], and @@Sums[2] each refer to an individual SumAccum<INT>, and @@Lists[0] and @@Lists[1] each refer to a ListAccum<STRING>, supporting all the operations for those accumulator and data types.

[source,text]
----
@@Sums[1] = 1;
@@Sums[1] += 2;  // value is now 3
@@Lists[0] = "cat";
@@Lists[0] += "egory";  // value is now "category"
----

==== Accumulator-level operations

The operators =, +=, and + have special meanings when applied to an ArrayAccum as a whole. There operations efficiently update an entire ArrayAccum.
All ArrayAccums must have the same element type.

|===
| Operator | Description | Example

| =
| Sets the ArrayAccum on the left equal to the ArrayAccum on the right. The two ArrayAccums must have the same element type, but the left-side ArrayAccum will change its size and dimensions to match the one on the right side.
| @A = @B;

| +
| Performs element-by-element addition of two ArrayAccums of the same type and size.  The result is a new ArrayAccum of the same size.
| @C = @A + @B;  // @A and @B must be the same size

| +=
| Performs element-by-element accumulation (+=) from the right-side ArrayAccum to the left-side ArrayAccum. They must be the same type and size.
| @A += @B;  // @A and @B must be the same size
|===

ArrayAccum also supports the following class functions.

[WARNING]
====
Functions that modify the ArrayAccum (mutator functions) can be used only under the following conditions:

* Mutator functions of global accumulators may only be used at the query-body level.
* Mutator functions of vertex-attached accumulators may only be used in a `POST-ACCUM` clause.
====

|===
| Function | Return type | Accessor / Mutator | Description

| `size()`
| INT
| Accessor
| Returns the total number of elements in the (multidimensional) array. For example, the size of an ArrayAccum declared as @A[3][4] is 12.

| `reallocate( INT, ... )`
| VOID
| Mutator
| Discards the previous ArrayAccum instance and creates a new ArrayAccum, with the size(s) given.
An N-dimensional ArrayAccum requires N integer parameters. The reallocate function cannot be used to change the number of dimensions.
|===

==== Example
[tabs]
====
Query::
+
--
.Example of ArrayAccum Element-level Operations
[source,gsql]
----
include::appendix:example$minimal_net/accum_arrayaccum.gsql[]
----
--

Results::
+
--
[source,gsql]
----
GSQL > RUN QUERY array_accum_elem()
include::appendix:example$minimal_net/accum_arrayaccum_results.json[]
----
--
====

[tabs]
====
Query::
+
--
[source,gsql]
----
include::appendix:example$minimal_net/accum_arrayaccum_op.gsql[]
----
--

Results::
+
--
[source,gsql]
----
include::appendix:example$minimal_net/accum_arrayaccum_op_run.gsql[]
include::appendix:example$minimal_net/accum_arrayaccum_op_results.json[]
----
--
====

[tabs]
====
Query::
+
--
[source,gsql]
----
include::appendix:example$social_net/accum_arrayaccum_local.gsql[]
----
--

Results::
+
--
[source,gsql]
----
GSQL > RUN QUERY array_accum_local()
include::appendix:example$social_net/accum_arrayaccum_local_results.json[]
----
--
====


[#_heapaccum]
=== HeapAccum

The HeapAccum type maintains a sorted collection of tuples and enforces a maximum number of tuples in the collection.
The output of a HeapAccum is a sorted collection of tuple elements.
The `+=` operation adds a tuple to the collection in sorted order. If the HeapAccum is already at maximum capacity when the `+=` operator is applied, then the tuple which is last in the sorted order is dropped from the HeapAccum.
Sorting of tuples is performed on one or more defined tuple fields ordered either ascending or descending.
Sorting precedence is performed based on defined tuple fields from left to right.

You must have defined a custom xref:data-types.adoc#_tuple[tuple type] to declare a `HeapAccum`, and one of the fields in the tuple must be a data type that can be sorted.

The declaration syntax is outlined in the figure below:

.HeapAccum declaration syntax
[source,ebnf]
----
HeapAccum<tupleType>( [capacity,] field_a [ASC|DESC],... , field_z [ASC|DESC]);
----

In the declaration of the `HeapAccum`, the keyword `HeapAccum` is followed by the tuple type in angle brackets `< >`.
This is followed by a parenthesized list of two or more parameters.

* If the first parameter is a positive integer, it sets the maximum number of tuples that the HeapAccum may store.
* The subsequent parameters are a subset of the tuple's field, which are used as sort keys.
The sort key hierarchy is from left to right, with the leftmost key being the primary sort key.
The keywords `ASC` and `DESC` indicate Ascending (lowest value first) or Descending (highest value first) sort order.
Ascending order is the default.

HeapAccum supports comparison with the `==` and the `!=` operators.
Comparison (and assignment with the `+=` operator) is only possible if two HeapAccums hold the same types of tuple and have the same sort order and direction.

HeapAccum capacity does not affect comparison.
Only the actual contents of are evaluated during comparison.

==== Functions
HeapAccum also supports the following class functions.

[WARNING]
====
Functions that modify the `HeapAccum` (mutator functions) can be used only under the following conditions:

* Mutator functions of global accumulators may only be used at the query-body level.
* Mutator functions of vertex-attached accumulators may only be used in a `POST-ACCUM` clause.
====

|===
| Function | Return type | Accessor / Mutator | Description

| `size()`
| `INT`
| Accessor
| Returns the number of elements in the heap.

| `top()`
| `tupleType`
| Accessor
| Returns the top tuple. If this heap is empty, returns a tuple with each element equal to the default value.

| `pop()`
| `tupleType`
| Mutator
| Returns the top tuple and removes it from the heap. If this heap is empty, returns a tuple with each element equal to the default value.

| `resize( INT newSize)`
| `VOID`
| Mutator
| Changes the maximum capacity of the heap.

| `clear()`
| `VOID`
| Mutator
| Clears the heap so it becomes empty with size 0.
|===

==== Example
[tabs]
====
Query::
+
--
[source,gsql]
----
include::appendix:example$minimal_net/accum_heapaccum.gsql[]
----
--

Results::
+
--
[source,gsql]
----
GSQL > RUN QUERY heap_accum_ex()
include::appendix:example$minimal_net/accum_heapaccum_results.json[]
----
--
====


=== GroupByAccum

The GroupByAccum is a compound accumulator, an accumulator of accumulators. At the top level, it is a MapAccum where both the key and the value can have multiple fields, each of them an accumulator type.

.GroupByAccum syntax
[source,ebnf]
----
GroupByAccum<type [, type]* , accumType [, accumType]* >
----



In the EBNF above, the *type* terms form the key set, and the *accumType* terms form the map's value. Since they are accumulators, they perform a grouping. Like a MapAccum, if we try to store a (key->value) whose key has already been used, then the new value will accumulate to the data which is already stored.
In this case, each field of the multiple-field value has its own accumulation function. One way to think about GroupByAccum is that each unique key is a group ID.

In GroupByAccum, the key types can be base type or tuple. The accumulators are used for aggregating group values.  Each accumulator type can be any type including HeapAccum. Each base type and each accumulator type must be followed an alias. Below is an example declaration.

[source,gsql]
----
TYPEDEF TUPLE <id INT, name STRING, age INT> My_Tuple;
TYPEDEF HeapAccum <My_Tuple> (2, name desc, age desc, id asc) My_Heap;
GroupByAccum<INT a, STRING b,
             MaxAccum<INT> maxa,
             ListAccum<ListAccum<INT>> lists,
             My_Heap h> @@group;
----

To add new data to this GroupByAccum, the data should be formatted as *(key1, key2 -> value1, value2)* .

GroupByAccum also supports the following class functions.

[WARNING]
====
Functions that modify the GroupByAccum (mutator functions) can be used only under the following conditions:

* Mutator functions of global accumulators may only be used at the query-body level.
* Mutator functions of vertex-attached accumulators may only be used in a `POST-ACCUM` clause.
====

|===
| Function (`KEY1..KEYn` are the key types) | Return type | Accessor / Mutator | Description

| `size()`
| `INT`
| Accessor
| Returns the number of elements in the heap.

| `get( KEY1 _key_value1_ , KEY2 _key_value2_ ... )`
| element type(s) of the accumulator(s)
| Accessor
| Returns the values from each accumulator in the group associating with the given key(s). If the key(s) doesn't exist, return the default value(s) of the accumulator type(s).

| `containsKey( KEY1 _key_value1_ , KEY2 _key_value2_... )`
| `BOOL`
| Accessor
| Returns true/false if the accumulator contains the key(s)

| `clear()`
| `VOID`
| Mutator
| Clears the heap so it becomes empty with size 0.

| `remove ( KEY1 _key_value1_ , KEY2 _key_value2_ ... )`
| VOID
| Mutator
| Removes the group associating with the key(s)
|===

==== Example
[tabs]
====
Query::
+
--
.GroupByAccum Example
[source,gsql]
----
include::appendix:example$social_net/accum_groupbyaccum.gsql[]
----
--

Results::
+
--
[source,gsql]
----
GSQL > RUN QUERY group_by_accum_ex()
include::appendix:example$social_net/accum_groupbyaccum_results.json[]
----
--
====


== Nested Accumulators

Certain collection accumulators may be nested. That is, an accumulator may contain a collection of elements where the elements themselves are accumulators. For example:

[source,gsql]
----
ListAccum<ListAccum<INT>> @@matrix; // a 2-dimensional jagged array of integers.  Each inner list has its own unique size.
----

Only ListAccum, ArrayAccum, MapAccum, and GroupByAccum can contain other accumulators. However, not all combinations of collection accumulators are allowed. The following constraints apply:

. ListAccum: ListAccum is the only accumulator type that can be nested within ListAccum:
+
[source,text]
----
ListAccum<ListAccum<INT>>
ListAccum<ListAccum<ListAccum<INT>>>
ListAccum<SetAccum<INT>> // illegal
----

. MapAccum: All accumulator types, except for HeapAccum, can be nested within MapAccum as the value type. For example,
+
[source,text]
----
MapAccum<STRING, ListAccum<INT>>
MapAccum<INT, MapAccum<INT, STRING>>
MapAccum<VERTEX, SumAccum<INT>>
MapAccum<STRING, SetAccum<VERTEX>>
MapAccum<STRING, GroupByAccum<VERTEX a, MaxAccum<INT> maxs>>
MapAccum<SetAccum<INT>, INT> # illegal
----

. GroupByAccum: All accumulator types, except for HeapAccum, can be nested within GroupByAccum as the accumulator type. For example:
+
[source,text]
----
GroupByAccum<INT a, STRING b, MaxAccum<INT> maxs, ListAccum<ListAccum<INT>> lists>
----

. ArrayAccum: Unlike the other accumulators in this list, where nesting is optional, nesting is mandatory for ArrayAccum. See the xref:querying:accumulators.adoc#_arrayaccum[ArrayAccum] section.

It is legal to define nested ListAccums to form a multidimensional array. Note the declaration statements and the nested [ bracket ] notation in the example below:

[tabs]
====
Query::
+
--
[source,text]
----
include::appendix:example$minimal_net/accum_nested_accum.gsql[]
----
--
Results::
+
--
[source,gsql]
----
GSQL > RUN QUERY nested_accum_ex()
include::appendix:example$minimal_net/accum_nested_accum_results.json[]
----
--
====

