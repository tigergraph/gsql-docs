= Accumulators

Accumulators are special types of variables that accumulate information about the graph during its traversal and exploration. Because they are a unique and important feature of the GSQL query language, we devote a separate section for their introduction, but additional detail on their usage will be covered in other sections, the xref:select-statement/sql-like-select-statement.adoc[`SELECT` Statement section] in particular.

This section covers the following subset of the EBNF language definitions:

.EBNF for accumulators
[source,ebnf]
----
accumDeclStmt :=
          accumType localAccumName ["=" constant]
                    ["," localAccumName ["=" constant]]*
        | [STATIC] accumType globalAccumName ["=" constant]
                    ["," globalAccumName ["=" constant]]*
localAccumName := "@"accumName;
globalAccumName := "@@"accumName;


accumType := "SumAccum" "<" ( INT | FLOAT | DOUBLE | STRING | STRING COMPRESS) ">"
       | "MaxAccum" "<" ( INT | FLOAT | DOUBLE ) ">"
       | "MinAccum" "<" ( INT | FLOAT | DOUBLE ) ">"
       | "AvgAccum"
       | "OrAccum"
       | "AndAccum"
       | "BitwiseOrAccum"
       | "BitwiseAndAccum"
       | "ListAccum" "<" type ">"
       | "SetAccum"  "<" elementType ">"
       | "BagAccum"  "<" elementType ">"
       | "MapAccum"  "<" elementType "," (baseType | accumType | tupleType) ">"
       | "HeapAccum" "<" tupleType ">" "(" simpleSize "," fieldName [ASC | DESC]
                                          ["," fieldName [ASC | DESC]]* ")"
       | "GroupByAccum" "<" elementType fieldName ["," elementType fieldName]* ,
		                     accumType fieldName ["," accumType fieldName]* ">"
       | "ArrayAccum" "<" accumName ">"

elementType := baseType | tupleType | STRING COMPRESS

gAccumAccumStmt := globalAccumName "+=" expr

accumClause := ACCUM DMLSubStmtList

postAccumClause := "POST-ACCUM" DMLSubStmtList
----


There are a number of different types of accumulators, each providing specific accumulation functions.  Accumulators are declared to have one of two types of association: _global_ or _vertex-attached_.

More technically, accumulators are mutable mutex variables shared among all the graph computation threads exploring the graph within a given query.
To improve performance, the graph processing engine employs multithreaded processing.
Modification of accumulators is coordinated at run-time so the accumulation operator works correctly (i.e., mutually exclusively) across all threads.

This is particularly relevant in the ACCUM clause. During traversal of the graph, the selected set of edges or vertices is partitioned among a group of threads.
These threads have shared mutually exclusive access to the accumulators.

== Declaration of Accumulators

Global accumulators can be declared anywhere in the query.
Vertex-attached accumulators can be declared anywhere in the query except for in a `FOREACH` loop or `WHILE` loop.
Accumulators are xref:querying:declaration-and-assignment-statements.adoc#_block_scoping[block-scoped] and can only be accessed in the block where they are declared.

The name of a vertex-attached accumulator begins with a single `@`. The name of a global accumulator begins with `@@`. Additionally, a global accumulator may be declared to be static.

.EBNF for Accumulator Declaration
[source,ebnf]
----
accumDeclStmt :=
          accumType localAccumName ["=" expr]
                    ["," localAccumName ["=" expr]]*
        | [STATIC] accumType globalAccumName ["=" expr]
                    ["," globalAccumName ["=" expr]]*
localAccumName := "@"accumName;
globalAccumName := "@@"accumName;
----

== Vertex-attached Accumulators

Vertex-attached accumulators are mutable state variables that are attached to each vertex in the graph for the duration of the query's lifetime.
They act as run-time attributes of a vertex. They are shared, mutual exclusively, among all query processes.

Vertex-attached accumulators can be set to a value with the `=` operator.
Additionally, an accumulate operator `+=` can be used to update the state of the accumulator; the function of `+=` depends on the accumulator type.
Vertex-attached accumulators can only be accessed or updated (via = or +=) in an `ACCUM` or `POST-ACCUM` clause within a `SELECT` statement or by a `PRINT` statement.

In the example below, there are two accumulators attached to each vertex.
The initial value of an accumulator of a given type is predefined, however it can be changed at declaration as in the accumulator @weight below.
All vertex-attached accumulator names have a single leading at-sign `@`.

.Vertex-Attached Accumulators
[source,gsql]
----
SumAccum<int>   @neighbors;
MaxAccum<float> @weight = 2.8;
----

If there is a graph with 10 vertices, then there is an instance of `@neighbors` and `@weight` for each vertex (hence 10 of each, and 20 total accumulator instances).
These are accessed via the dot operator on a vertex variable or a vertex alias (e.g., `v.@neighbor`).
The accumulator operator += only impacts the accumulator for the specific vertex being referenced.
A statement such as ``v1.@neighbors += 1``will only impact `v1` 's `@neighbors` and not the `@neighbors` for other vertices.


== Global Accumulators

A global accumulator is a single mutable accumulator that can be accessed or updated within a query. The names of global accumulators start with a double at-sign `@@`.

.Global Accumulators
[source,gsql]
----
SumAccum<int>   @@totalNeighbors;
MaxAccum<float> @@entropy = 1.0;
----


Global accumulators can only be assigned (using the `=` operator) outside a `SELECT` block (i.e., not within an `ACCUM` or `POST-ACCUM` clause).
Global accumulators can be accessed or updated via the accumulate operator `+=` anywhere within a query, including inside a SELECT block.

The accumulation operation for global accumulators in an ACCUM clause executes once for each process. That is:

* if the FROM clause uses an edge-induced selection (introduced in Section "SELECT Statement"), the ACCUM clause executes one process for each edge in the selected edge set.
* If the FROM clause uses a vertex-induced selection (introduced in Section "SELECT Statement"), the ACCUM clause executes one process for each vertex in the selected vertex set.

Since global accumulators are shared in a mutually exclusive manner among processes, they behave very differently than a non-accumulator variable (see Section "Variable Types" for more details) in an ACCUM clause.

Take the following code example. The global accumulator `@@globalRelationshipCount` is accumulated for every `worksFor` edge traversed since it is shared among processes. Conversely, `relationshipCount` appears to have only been incremented once.

This is because a non-accumulator variable is not shared among processes.
Each process has its own separate unshared copy of `relationshipCount` and increments the original value by one. (E.g., each process increments *relationshipCount* from 0 to 1.) There is no accumulation and the final value is one.

=== Example
[tabs]
====
Query::
+
--
.Global Variable vs Global Accumulator
[source,gsql]
----
#Count the total number of employment relationships for all companies
CREATE QUERY countEmploymentRelationships() FOR GRAPH workNet {

  INT localRelationshipCount;
  SumAccum<INT> @@globalRelationshipCount;

  start = {company.*};

  companies = SELECT s FROM start:s -(worksFor)-> :t
          ACCUM @@globalRelationshipCount += 1,
                localRelationshipCount = localRelationshipCount + 1;

  PRINT localRelationshipCount;
  PRINT @@globalRelationshipCount;
}
----
--

Results::
+
--
.countEmploymentRelationship.json Results
[source,gsql]
----
GSQL > RUN QUERY countEmploymentRelationships()
{
  "error": false,
  "message": "",
  "version": {
    "edition": "developer",
    "schema": 0,
    "api": "v2"
  },
  "results": [
    {"localRelationshipCount": 1},
    {"@@globalRelationshipCount": 17}
  ]
}
----
--
====


=== Static Global Accumulators

A static global accumulator retains its value after the execution of a query. To declare a static global accumulator, include the STATIC keyword at the beginning of the declaration statement. For example, if a static global accumulator is incremented by 1 each time a query is executed, then its value is equal to the number of times the query has been run, since the query was installed. Each static global accumulator belongs to the particular query in which it is declared; it cannot be shared among different queries. The value only persists in the context of running the same query multiple times.  The value will reset to the default value when the GPE is restarted.


==== Example
[tabs]
====
Query::
+
--
.Static Global Accumulators example
[source,gsql]
----
CREATE QUERY staticAccumEx(INT x) FOR GRAPH minimalNet {
  STATIC ListAccum<INT> @@testList;
  @@testList += x;
  PRINT @@testList;
}
----
--
Results::
+
--
.staticAccumEx.json Result
[source,gsql]
----
GSQL > RUN QUERY staticAccumEx(3)
{
  "error": false,
  "message": "",
  "version": {
    "edition": "developer",
    "schema": 0,
    "api": "v2"
  },
  "results": [{"@@testList": [
    3,
    -5,
    3
  ]}]
}
GSQL > RUN QUERY staticAccumEx(-5)
{
  "error": false,
  "message": "",
  "version": {
    "edition": "developer",
    "schema": 0,
    "api": "v2"
  },
  "results": [{"@@testList": [
    3,
    -5,
    3,
    -5
  ]}]
}
----
--
====


There is no command to deallocate a static global accumulator. If a static global accumulator is a collection accumulator and is no longer needed, it should be cleared to minimize memory usage.

== Accumulator Types

The following are the accumulator types we currently support. Each type of accumulator supports one or more data types.

.EBNF for Accumulator Types
[source,ebnf]
----
accumType := "SumAccum" "<" ( INT | FLOAT | DOUBLE | STRING | STRING COMPRESS) ">"
		   | "MaxAccum" "<" ( INT | FLOAT | DOUBLE ) ">"
 	     | "MinAccum" "<" ( INT | FLOAT | DOUBLE ) ">"
     	 | "AvgAccum"
		   | "OrAccum"
		   | "AndAccum"
       | "BitwiseOrAccum"
       | "BitwiseAndAccum"
		   | "ListAccum" "<" type ">"
		   | "SetAccum"  "<" elementType ">"
		   | "BagAccum"  "<" elementType ">"
       | "MapAccum"  "<" elementType "," (baseType | accumType | tupleType) ">"
       | "HeapAccum" "<" tupleType ">" "(" simpleSize "," fieleName [ASC | DESC]
                               ["," fieldName [ASC | DESC]]* ")"
		   | "GroupByAccum" "<" elementType fieldName ["," elementType fieldName]* ,
		                        accumType fieldName ["," accumType fieldName]* ">"
       | "ArrayAccum" "<" accumName ">"

elementType := baseType | tupleType | STRING COMPRESS

gAccumAccumStmt := globaAccumName "+=" expr
----



The accumulators fall into two major groups :

* *Scalar Accumulators* store a single value:
 ** SumAccum
 ** MinAccum, MaxAccum
 ** AvgAccum
 ** AndAccum, OrAccum
 ** BitwiseAndAccum, BitwiseOrAccum
* *Collection Accumulators* store a set of values:
 ** ListAccum
 ** SetAccum
 ** BagAccum
 ** MapAccum
 ** ArrayAccum
 ** HeapAccum
 ** GroupByAccum

The details of each accumulator type are summarized in the table below.  The Accumulation Operation column explains how the accumulator *accumName* is updated when the statement *accumName += newVal* is executed. Following the table are example queries for each accumulator type.

.Accumulator Types and Their Accumulation Behavior
[width="100%",cols="<34%,<33%,<33%",options="header",]
|===
|Accumulator Type (Case Sensitive) |Default Initial Value |Accumulation
operation +
+
(result of __`+accumName +`__`+= +`_`+newVal +`_)
|SumAccum<INT> |0 |_accumName_ plus _newVal_

|SumAccum<FLOAT or DOUBLE> |0.0 |_accumName_ plus _newVal_

|SumAccum<STRING> |empty string |String concatenation of _accumName_ and
_newVal_

|MaxAccum<INT> |INT_MIN |The greater of _newVal_ and _accumName_

|MaxAccum<FLOAT or DOUBLE> |FLOAT_MIN or DOUBLE_MIN |The greater of
_newVal_ and _accumName_

|MaxAccum<STRING> |empty string |The greater of _newVal_ and _accumName_
_,_ according to UTF-8 lexicographical ordering

|MaxAccum<VERTEX> |the vertex with internal id 0 |The vertex with the
greater internal id , either _newVal_ or _accumName_

|MaxAccum<tupleTyple> |default for each field of the tuple |The greater
of _newVal_ and _accumName._ tupleType is a user-defined sequence of
baseTypes. Ordering is hierarchical, using the leftmost field of the
tuple first, then the next field, and so on.

|MinAccum<INT> |INT_MAX |The lesser of _newVal_ and _accumName_

|MinAccum<FLOAT or DOUBLE> |FLOAT_MAX or DOUBLE_MAX |The lesser of
_newVal_ and _accumName_

|MinAccum<STRING> |empty string |The lesser of _newVal_ and _accumName_
_,_ according to UTF-8 lexicographical ordering

|MinAccum<VERTEX> |unknown |The vertex with the lesser internal id,
either _newVal_ or _accumName_

|MinAccum<tupleType> |default for each field of the tuple |The lesser of
_newVal_ and _accumName._ tupleType is a user-defined sequence of
baseTypes. Ordering is hierarchical, using the leftmost field of the
tuple first, then the next field, and so on.

|AvgAccum |0.0 (double precision) |Double precision average of _newVal_
and all previous values accumulated to__accumName__

|AndAccum |True |Boolean AND of _newVal_ and _accumName_

|OrAccum |False |Boolean OR of _newVal_ and _accumName_

|BitwiseAndAccum |-1 (INT) = 64-bit sequence of 1s |Bitwise AND of
_newVal_ and _accumName_

|BitwiseOrAccum |0 (INT) = 64-bit sequence of 0s |Bitwise OR of _newVal_
and _accumName_ +
+

a|
ListAccum< _type_ >

(ordered collection of elements)

|empty list |List with _newVal_ appended to end of _accumName. newVal_
can be a single value or a list. If _accumName_ is [ 2, 4, 6 ], then
_accumName_ = 4 +
+
produces _accumName_ equal to [.2]##

a|
SetAccum< t__ype__ >

(unordered collection of elements, duplicate items not allowed)

|empty set |Set union of _newVal_ and _accumName_ . _newVal_ can be a
single value or a set/bag.If _accumName_ is ( 2, 4, 6 ), then
_accumName_ = 4 +
+
produces _accumName_ equal to ( 2, 4, 6)

a|
BagAccum<t__ype__ >

(unordered collection of elements, duplicate items allowed)

|empty bag |Bag union of _newVal_ and _accumName_ . _newVal_ can be a
single value or a set/bag.If _accumName_ is ( 2, 4, 6 ), then
_accumName_ = 4 +
+
would result in _accumName_ equal to ( 2, 4, 4, 6)

a|
MapAccum< _type, type_ >

(unordered collection of (key,value) pairs)

|empty map |Add or update a key:value pair to the _accumName_ map. If
_accumName_ is [ ("red",3), ("green",4),("blue",2) ], then _accumName_
+= ("black"â†’ 5) +
+
produces _accumName_ equal to [.("red"]##

|ArrayAccum< _accumType_ > |empty list |See the ArrayAccum section below
for details.

a|
HeapAccum< _tuple_ >(heapSize, sortKey *)*

(sorted collection of tuples)

|empty heap |Insert _newVal_ into the _accumName_ heap, maintaining the
heap in sorted order, according to the sortKey(s) and size limit
declared for this HeapAccum

|GroupByAccum< _type [, type] , accumType [, accumType]*_ > |empty group
by map |Add or update a key:value pair in _accumName_ . See Section
"GroupByAccum" for more details.
|===


=== SumAccum

The SumAccum type computes and stores the cumulative sum of numeric values or the cumulative concatenation of text values. The output of a SumAccum is a single numeric or string value. SumAccum variables operate on values of type INT, UINT, FLOAT, DOUBLE, or STRING only.

The *+=* operator updates the accumulator's state. For INT, FLOAT, and DOUBLE types, *+= `arg`* performs a numeric addition, while for the STRING value type *+= `arg`* concatenates *arg* to the current value of the SumAccum.

==== Example

[tabs]
====
Query::
+
--
.SumAccum Example
[source,gsql]
----
# SumAccum Example
CREATE QUERY sumAccumEx() FOR GRAPH minimalNet {

  SumAccum<INT>    @@intAccum;
  SumAccum<FLOAT>  @@floatAccum;
  SumAccum<DOUBLE> @@doubleAccum;
  SumAccum<STRING> @@stringAccum;

  @@intAccum  = 1;
  @@intAccum += 1;

  @@floatAccum = @@intAccum;
  @@floatAccum = @@floatAccum / 3;

  @@doubleAccum  = @@floatAccum * 8;
  @@doubleAccum += -1;

  @@stringAccum  = "Hello ";
  @@stringAccum += "World";

  PRINT @@intAccum;
  PRINT @@floatAccum;
  PRINT @@doubleAccum;
  PRINT @@stringAccum;
}
----
--

Results::
+
--
.sumAccumEx.json Result
[source,gsql]
----
GSQL > RUN QUERY sumAccumEx()
{
  "error": false,
  "message": "",
  "version": {
    "edition": "developer",
    "schema": 0,
    "api": "v2"
  },
  "results": [
    {"@@intAccum": 2},
    {"@@floatAccum": 0.66667},
    {"@@doubleAccum": 4.33333},
    {"@@stringAccum": "Hello World"}
  ]
}
----
--
====


=== MinAccum / MaxAccum

The `MinAccum` and `MaxAccum` types calculate and store the cumulative minimum or the cumulative maximum of a series of values. The output of a `MinAccum` or a `MaxAccum` is a single value of the type that was passed in. `MinAccum` and `MaxAccum` variables operate on values of type `INT, UINT, FLOAT, DOUBLE, STRING, TUPLE`, and `VERTEX` (with optional specific vertex type) only.

For `MinAccum`, *+= `arg`* checks if the current value held is less than *arg* and stores the smaller of the two. `MaxAccum` behaves the same, with the exception that it checks for and stores the greater instead of the lesser of the two.

==== Example
[tabs]
====
Query::
+
--
.MinAccum and MaxAccum Example
[source,gsql]
----
# MinAccum and MaxAccum Example
CREATE QUERY minMaxAccumEx() FOR GRAPH minimalNet {

  MinAccum<INT> @@minAccum;
  MaxAccum<FLOAT> @@maxAccum;

  @@minAccum += 40;
  @@minAccum += 20;
  @@minAccum += -10;

  @@maxAccum += -1.1;
  @@maxAccum += 2.5;
  @@maxAccum += 2.8;

  PRINT @@minAccum;
  PRINT @@maxAccum;
}
----
--

Results::
+
--
.minMaxAccumEx.json Result
[source,gsql]
----
GSQL > RUN QUERY minMaxAccumEx()
{
  "error": false,
  "message": "",
  "version": {
    "edition": "developer",
    "schema": 0,
    "api": "v2"
  },
  "results": [
    {"@@minAccum": -10},
    {"@@maxAccum": 2.8}
  ]
}
----
--
====



String minimum and maximum values are based on their UTF-8 codes, which is a multilingual superset of the ASCII codes.
Within ASCII, a < z, uppercase is less than lowercase, and digits are less than alphabetic characters.

MinAccum and MaxAccum operating on VERTEX type have a special comparison.
They do not compare vertex ids, but TigerGraph internal ids, which might not be in the same order as the external ids.
Comparing internal ids is much faster, so MinAccum/MaxAccum<VERTEX> provides an efficient way to compare and select vertices.
This is helpful for some graph algorithms that require the vertices to be numbered and sortable.
For example, the following query returns one post from each person. The returned vertex is not necessarily the vertex with the alphabetically largest id.

[tabs]
====
Query::
+
--
[source,gsql]
----
# Output one random post vertex from each person
CREATE QUERY minMaxAccumVertex() FOR GRAPH socialNet api("v2") {

  MaxAccum<VERTEX> @maxVertex;
  allUser = {person.*};
  allUser = SELECT src
            FROM allUser:src -(posted)-> post:tgt
            ACCUM src.@maxVertex += tgt
            ORDER BY src.id;
  PRINT allUser[allUser.@maxVertex]; // api v2
}
----
--

Results::
+
--
.minMaxAccuxVertex.json Result
[source,gsql]
----
GSQL > RUN QUERY minMaxAccumVertex()
{
  "error": false,
  "message": "",
  "version": {
    "edition": "developer",
    "schema": 0,
    "api": "v2"
  },
  "results": [{"allUser": [
    {
      "v_id": "person1",
      "attributes": {"allUser.@maxVertex": "0"},
      "v_type": "person"
    },
    {
      "v_id": "person2",
      "attributes": {"allUser.@maxVertex": "1"},
      "v_type": "person"
    },
    {
      "v_id": "person3",
      "attributes": {"allUser.@maxVertex": "2"},
      "v_type": "person"
    },
    {
      "v_id": "person4",
      "attributes": {"allUser.@maxVertex": "3"},
      "v_type": "person"
    },
    {
      "v_id": "person5",
      "attributes": {"allUser.@maxVertex": "11"},
      "v_type": "person"
    },
    {
      "v_id": "person6",
      "attributes": {"allUser.@maxVertex": "10"},
      "v_type": "person"
    },
    {
      "v_id": "person7",
      "attributes": {"allUser.@maxVertex": "9"},
      "v_type": "person"
    },
    {
      "v_id": "person8",
      "attributes": {"allUser.@maxVertex": "7"},
      "v_type": "person"
    }
  ]}]
}
----
--
====


Tuple data types are treated as hierarchical structures, where the first field used for ordering is the leftmost one.
When a tuple is used as an element of a `MinAccum` or `MaxAccum`, tuple fields can be directly accessed from the accumulator.
For example, if we have the following tuple type and `MaxAccum` :

[source,text]
----
TYPEDEF TUPLE <FLOAT weight> EDGE_WEIGHT
MinAccum<EDGE_WEIGHT> @@AccTest;
----

Then the `weight` field of the tuple can be accessed directly from the `MacAccum` through the doc operator(`.`):

[source,cpp]
----
@@AccTest.weight // Will return the weight field value for the EDGE_WEIGHT
                 // type tuple stored in the MaxAccum
----

=== AvgAccum

The AvgAccum type calculates and stores the cumulative mean of a series of numeric values. Internally, its state information includes the sum value of all inputs and a count of how many input values it has accumulated. The output is the mean value; the sum and the count values are not accessible to the user. The data type of an AvgAccum variable is not declared; all AvgAccum accumulators accept inputs of type INT, UINT, FLOAT, and DOUBLE.  The output is always DOUBLE type.

The *+= arg* operation updates the AvgAccum variable's state to be the mean of all the previous arguments along with the current argument; The *`= arg`* operation clears all the previously accumulated state and sets the new state to be *arg* with a count of one.

==== Example
[tabs]
====
Query::
+
--
.AvgAccum Example
[source,gsql]
----
# AvgAccum Example
CREATE QUERY avgAccumEx() FOR GRAPH minimalNet {

  AvgAccum @@averageAccum;

  @@averageAccum += 10;
  @@averageAccum += 5.5; # avg = (10+5.5) / 2.0
  @@averageAccum += -1;  # avg = (10+5.5-1) / 3.0

  PRINT @@averageAccum;  # 4.8333...

  @@averageAccum = 99;   # reset
  @@averageAccum += 101; # avg = (99 + 101) / 2

  PRINT @@averageAccum;  # 100
}
----
--

Results::
+
--
.avgAccumEx.json Result
[source,gsql]
----
GSQL > RUN QUERY avgAccumEx()
{
  "error": false,
  "message": "",
  "version": {
    "edition": "developer",
    "schema": 0,
    "api": "v2"
  },
  "results": [
    {"@@averageAccum": 4.83333},
    {"@@averageAccum": 100}
  ]
}
----
--
====


=== AndAccum / OrAccum

The AndAccum and OrAccum types calculate and store the cumulative result of a series of boolean operations. The output of an AndAccum or an OrAccum is a single boolean value (True or False). AndAccum and OrAccum variables operate on boolean values only.  The data type does not need to be declared.

For AndAccum, *+= arg* updates the state to be the logical AND between the current boolean state and *arg*. OrAccum behaves the same, with the exception that it stores the result of a logical OR operation.

==== Example
[tabs]
====
Query::
+
--
.AndAccum and OrAccum Example
[source,gsql]
----
# AndAccum and OrAccum Example
CREATE QUERY andOrAccumEx() FOR GRAPH minimalNet {
  # T = True
  # F = False

  AndAccum @@andAccumVar; # (default value = T)
  OrAccum  @@orAccumVar;  # (default value = F)

  @@andAccumVar += True;  # T and T = T
  @@andAccumVar += False; # T and F = F
  @@andAccumVar += True;  # F and T = F

  PRINT @@andAccumVar;

  @@orAccumVar += False;  # F or F == F
  @@orAccumVar += True;   # F or T == T
  @@orAccumVar += False;  # T or F == T

  PRINT @@orAccumVar;
}
----
--

Results::
+
--
.andOrAccumEx.json Result
[source,gsql]
----
GSQL > RUN QUERY andOrAccumEx()
{
  "error": false,
  "message": "",
  "version": {
    "edition": "developer",
    "schema": 0,
    "api": "v2"
  },
  "results": [
    {"@@andAccumVar": false},
    {"@@orAccumVar": true}
  ]
}
----
--
====


=== BitwiseAndAccum / BitwiseOrAccum

The BitwiseAndAccum and BitwiseOrAccum types calculate and store the cumulative result of a series of bitwise boolean operations and store the resulting bit sequences. BitwiseAndAccum and BitwiseOrAccum operator on INT only. The data type does not need to be declared.

Fundamental for understanding and using bitwise operations is the knowledge that integers are stored in base-2 representation as a 64-bit sequence of 1s and 0s. "Bitwise" means that each bit is treated as a separate boolean value, with 1 representing true and 0 representing false. Hence, an integer is equivalent to a sequence of boolean values. Computing the Bitwise AND of two numbers A and B means to compute the bit sequence C where the j th bit of C, denoted C j , is equal to (A j AND B j ).

For BitwiseAndAccum, *+= `arg`* updates the accumulator's state to be the Bitwise AND of the current state and *arg* `.` BitwiseOrAccum behaves the same, with the exception that it computes a Bitwise OR.

[CAUTION]
====
Bitwise Operations and Negative Integers

Most computer systems represent negative integers using "2's complement" format, where the uppermost bit has special significance. Operations that affect the uppermost bit are crossing the boundary between positive and negative numbers, and vice versa.
====

==== Example
[tabs]
====
Query::
+
--
.BitwiseAndAccum and BitwiseOrAccum Example
[source,gsql]
----
# BitwiseAndAccum and BitwiseOrAccum Example
CREATE QUERY bitwiseAccumEx() FOR GRAPH minimalNet {

  BitwiseAndAccum @@bwAndAccumVar; # default value = 64-bits of 1 = -1 (INT)
  BitwiseOrAccum  @@bwOrAccumVar;  # default value = 64-bits of 0 = 0 (INT))

  # 11110000 = 240
  # 00001111 =  15
  # 10101010 = 170
  # 01010101 =  85

  # BitwiseAndAccum
  @@bwAndAccumVar += 170; # 11111111 & 10101010 -> 10101010
  @@bwAndAccumVar +=  85; # 10101010 & 01010101 -> 00000000
  PRINT @@bwAndAccumVar;  # 0

  @@bwAndAccumVar = 15;   # reset to 00001111
  @@bwAndAccumVar += 85;  # 00001111 & 01010101 -> 00000101
  PRINT @@bwAndAccumVar;  # 5

  # BitwiseOrAccum
  @@bwOrAccumVar += 170; # 00000000 | 10101010 -> 10101010
  @@bwOrAccumVar +=  85; # 10101010 | 01010101 -> 11111111 = 255
  PRINT @@bwOrAccumVar;  # 255

  @@bwOrAccumVar = 15;   # reset to 00001111
  @@bwOrAccumVar += 85;  # 00001111 | 01010101 -> 01011111 = 95
  PRINT @@bwOrAccumVar;  # 95
}
----
--

Results::
+
--
.bitwiseAccumEx.json Result
[source,gsql]
----
GSQL > RUN QUERY bitwiseAccumEx()
{
  "error": false,
  "message": "",
  "version": {
    "edition": "developer",
    "schema": 0,
    "api": "v2"
  },
  "results": [
    {"@@bwAndAccumVar": 0},
    {"@@bwAndAccumVar": 5},
    {"@@bwOrAccumVar": 255},
    {"@@bwOrAccumVar": 95}
  ]
}
----
--
====


=== ListAccum

The ListAccum type maintains a sequential collection of elements. The output of a ListAccum is a list of values in the order the elements were added. The element type can be any base type, tuple, or STRING COMPRESS. Additionally, a ListAccum can contain a nested collection of type ListAccum. Nesting of ListAccums is limited to a depth of three.

The *+= arg* operation appends `arg` to the end of the list. In this case, `arg` may be either a single element or another ListAccum.

ListAccum supports two additional operations:

* *@list1 + @list2* creates a new ListAccum, which contains the elements of @list1 followed by the elements of @list2. The two ListAccums must have identical data types.

[WARNING]
====
Change in "+" definition

The pre-v2.0 definition of the ListAccum "+" operator ( *@list + arg*: Add arg to each member of @list) is no longer supported.
====

* *@list1 * @list2* (STRING data only) generates a new list of strings consisting of all permutations of an element of the first list followed by an element of the second list.

ListAccum also supports the following class functions.

[WARNING]
====
Functions that modify the ListAccum (mutator functions) can be used only under the following conditions:

* Mutator functions of global accumulators may only be used at the query-body level.
* Mutator functions of vertex-attached accumulators may only be used in a POST-ACCUM clause.
====

|===
| Function (T is the element type) | Return type | Accessor / Mutator | Description

| `.size()`
| `INT`
| Accessor
| Returns the number of elements in the list.

| `.contains(* T _val_ *)`
| `BOOL`
| Accessor
| Returns true/false if the list does/doesn't contain the _value_ .

| `.get( INT _idx_ )`
| T
| Accessor
| Returns the value at the given _index_ position in the list. The index begins at 0. If the index is out of bound (including any negative value), the default value of the element type is returned.

| `.clear()`
| `VOID`
| Mutator
| Clears the list so it becomes empty with size 0.

| `.update (INT _index,_ T _value_ )`
| `VOID`
| Mutator
| Assigns _value_ to the list element at position _index_.

|`.remove(INT _index_)`
|`VOID`
|Mutator
|Removes value at the specified index. If the index is invalid, the function will do nothing.

|`.removeOne(T _value_)`
|`VOID`
|Mutator
|Removes the first matching value. If there is no matching value, the function will do nothing.

|`.removeAll(T _value_)`
|`VOID`
|Mutator
|Removes all matching values. If there is no matching value, the function will do nothing.
|===

==== Examples
[tabs]
====
Query::
+
--
.ListAccum Example
[source,gsql]
----
# ListAccum Example
CREATE QUERY listAccumEx() FOR GRAPH minimalNet {

  ListAccum<INT> @@intListAccum;
  ListAccum<STRING> @@stringListAccum;
  ListAccum<STRING> @@stringMultiplyListAccum;
  ListAccum<STRING> @@stringAdditionAccum;
  ListAccum<STRING> @@letterListAccum;
  ListAccum<ListAccum<STRING>> @@nestedListAccum;

  @@intListAccum = [1,3,5];
  @@intListAccum += [7,9];
  @@intListAccum += 11;
  @@intListAccum += 13;
  @@intListAccum += 15;

  PRINT @@intListAccum;
  PRINT @@intListAccum.get(0), @@intListAccum.get(1);
  PRINT @@intListAccum.get(8); # Out of bound: default value of int: 0

  #Other built-in functions
  PRINT @@intListAccum.size();
  PRINT @@intListAccum.contains(2);
  PRINT @@intListAccum.contains(3);

  @@stringListAccum += "Hello";
  @@stringListAccum += "World";

  PRINT @@stringListAccum; // ["Hello","World"]

  @@letterListAccum += "a";
  @@letterListAccum += "b";

  # ListA + ListB produces a new list equivalent to ListB appended to ListA.
  # Ex: [a,b,c] + [d,e,f] => [a,b,c,d,e,f]
  @@stringAdditionAccum = @@stringListAccum + @@letterListAccum;

  PRINT @@stringAdditionAccum;

  #Multiplication produces a list of all list-to-list element combinations (STRING TYPE ONLY)
  # Ex: [a,b] * [c,d] = [ac, ad, bc, bd]
  @@stringMultiplyListAccum = @@stringListAccum * @@letterListAccum;

  PRINT @@stringMultiplyListAccum;

  #Two dimensional list (3 dimensions is possible as well)
  @@nestedListAccum += [["foo", "bar"], ["Big", "Bang", "Theory"], ["String", "Theory"]];

  PRINT @@nestedListAccum;
  PRINT @@nestedListAccum.get(0);
  PRINT @@nestedListAccum.get(0).get(1);
}
----
--

Results::
+
--
.listAccumEx.json Result
[source,gsql]
----
GSQL > RUN QUERY listAccumEx()
{
  "error": false,
  "message": "",
  "version": {
    "edition": "developer",
    "schema": 0,
    "api": "v2"
  },
  "results": [ {"@@intListAccum": [ 1, 3, 5, 7, 9, 11, 13, 15 ]},
    {
      "@@intListAccum.get(0)": 1,
      "@@intListAccum.get(1)": 3
    },
    {"@@intListAccum.get(8)": 0},
    {"@@intListAccum.size()": 8},
    {"@@intListAccum.contains(2)": false},
    {"@@intListAccum.contains(3)": true},
    {"@@stringListAccum": [ "Hello", "World" ]},
    {"@@stringAdditionAccum": [ "Hello", "World", "a", "b"]},
    {"@@stringMultiplyListAccum": [ "Helloa", "Worlda", "Hellob", "Worldb" ]},
    {"@@nestedListAccum": [
      [ "foo", "bar" ],
      [ "Big", "Bang", "Theory" ],
      [ "String", "Theory" ]
    ]},
    {"@@nestedListAccum.get(0)": [ "foo", "bar" ]},
    {"@@nestedListAccum.get(0).get(1)": "bar"}
  ]
}
----
--
====

[tabs]
====
Query::
+
--
.Example for update function on a global ListAccum
[source,gsql]
----
CREATE QUERY listAccumUpdateEx() FOR GRAPH workNet {

  # Global ListAccum
  ListAccum<INT> @@intListAccum;
  ListAccum<STRING> @@stringListAccum;
  ListAccum<BOOL> @@passFail;

  @@intListAccum += [0,2,4,6,8];
  @@stringListAccum += ["apple","banana","carrot","daikon"];

  # Global update at Query-Body Level
  @@passFail += @@intListAccum.update(1,-99);
  @@passFail += @@intListAccum.update(@@intListAccum.size()-1,40);  // last element
  @@passFail += @@stringListAccum.update(0,"zero"); // first element
  @@passFail += @@stringListAccum.update(4,"four"); // FAIL: out-of-range

  PRINT @@intListAccum, @@stringListAccum, @@passFail;
}
----
--

Results::
+
--
.Results in listAcccumUpdateEx.json
[source,gsql]
----
GSQL > RUN QUERY listAccumUpdateEx()
{
  "error": false,
  "message": "",
  "version": {
    "edition": "developer",
    "schema": 0,
    "api": "v2"
  },
  "results": [{
    "@@passFail": [ true, true, true, false ],
    "@@intListAccum": [ 0, -99, 4, 6, 40 ],
    "@@stringListAccum": [ "zero", "banana", "carrot", "daikon" ]
  }]
}
----
--
====

[tabs]
====
Query::
+
--
.Example for update function on a vertex-attached ListAccum
[source,gsql]
----
CREATE QUERY listAccumUpdateEx2(SET<VERTEX<person>> seed) FOR GRAPH workNet api("v2") {

  # Each person has an LIST<INT> of skills and a LIST<STRING COMPRESS> of interests.
  # This function copies their lists into ListAccums, and then udpates the last
  # int with -99 and updates the last string with "fizz".
  ListAccum<INT> @intList;
  ListAccum<STRING COMPRESS> @stringList;
  ListAccum<STRING> @@intFails, @@strFails;

  S0 (person) = seed;
  S1 = SELECT s
    FROM S0:s
    ACCUM
      s.@intList = s.skillList,
      s.@stringList = s.interestList
    POST-ACCUM
      INT len = s.@intList.size(),
      IF NOT s.@intList.update(len-1,-99) THEN
        @@intFails += s.id END,
      INT len2 = s.@stringList.size(),
      IF NOT s.@stringList.update(len2-1,"fizz") THEN
        @@strFails += s.id END
  ;
  PRINT S1[S1.skillList, S1.interestList, S1.@intList, S1.@stringList]; // api v2
  PRINT @@intFails, @@strFails;
}
----
--

Results::
+
--
.Results for listAccumUpdateEx2
[source,gsql]
----
GSQL > RUN QUERY listAccumUpdateEx2(["person1","person5"])
{
  "error": false,
  "message": "",
  "version": {
    "edition": "developer",
    "schema": 0,
    "api": "v2"
  },
  "results": [
    {"S1": [
      {
        "v_id": "person1",
        "attributes": {
          "S1.@stringList": [ "management","fizz" ],
          "S1.interestList": [ "management", "financial"],
          "S1.skillList": [  1, 2, 3 ],
          "S1.@intList": [ 1, 2, -99 ]
        },
        "v_type": "person"
      },
      {
        "v_id": "person5",
        "attributes": {
          "S1.@stringList": [ "sport", "financial", "fizz" ],
          "S1.interestList": [ "sport", "financial", "engineering" ],
          "S1.skillList": [ 8, 2, 5 ],
          "S1.@intList": [ 8, 2, -99 ]
        },
        "v_type": "person"
      }
    ]},
    {
      "@@strFails": [],
      "@@intFails": []
    }
  ]
}
----
--
====


=== SetAccum

The SetAccum type maintains a collection of unique elements. The output of a SetAccum is a list of elements in arbitrary order. A SetAccum instance can contain values of one type. The element type can be any base type, tuple, or STRING COMPRESS.

For SetAccum, the *+= arg* operation adds a non-duplicate element or set of elements to the set. If an element is already represented in the set, then the SetAccum state does not change.

SetAccum also can be used with the three canonical set operators: UNION, INTERSECT, and MINUS (see Section "Set/Bag Expression and Operators" for more details).

SetAccum also supports the following class functions.

[WARNING]
====
Functions that modify the SetAccum (mutator functions) can be used only under the following conditions:

* Mutator functions of global accumulators may only be used at the query-body level.
* Mutator functions of vertex-attached accumulators may only be used in a POST-ACCUM clause.
====

|===
| Function (T is the element type) | Return type | Accessor / Mutator | Description

| *size()*
| INT
| Accessor
| Returns the number of elements in the set.

| *contains(* T _value_ *)*
| BOOL
| Accessor
| Returns true/false if the set does/doesn't contain the _value_.

| *remove(* T _value *)*_
| VOID
| Mutator
| Removes _value_ from the set.

| *clear()*
| VOID
| Mutator
| Clears the set so it becomes empty with size 0.
|===

==== Example
[tabs]
====
Query::
+
--
.SetAccum Example
[source,gsql]
----
# SetAccum Example
CREATE QUERY setAccumEx() FOR GRAPH minimalNet {

  SetAccum<INT> @@intSetAccum;
  SetAccum<STRING> @@stringSetAccum;

  @@intSetAccum += 5;
  @@intSetAccum.clear();

  @@intSetAccum += 4;
  @@intSetAccum += 11;
  @@intSetAccum += 1;
  @@intSetAccum += 11; # Sets do not store duplicates

  @@intSetAccum += (1,2,3,4); # Can create simple sets this way
  PRINT @@intSetAccum;
  @@intSetAccum.remove(2);
  PRINT @@intSetAccum AS RemovedVal2; # Demostrate remove.

  PRINT @@intSetAccum.contains(3);

  @@stringSetAccum += "Hello";
  @@stringSetAccum += "Hello";
  @@stringSetAccum += "There";
  @@stringSetAccum += "World";
  PRINT @@stringSetAccum;

  PRINT @@stringSetAccum.contains("Hello");
  PRINT @@stringSetAccum.size();
}
----
--

Results::
+
--
.setAccumEx.json Result
[source,gsql]
----
GSQL > RUN QUERY setAccumEx()
{
  "error": false,
  "message": "",
  "version": {
    "edition": "developer",
    "schema": 0,
    "api": "v2"
  },
  "results": [ {"@@intSetAccum": [ 3, 2, 1, 11, 4 ]},
    {"@@intSetAccum.contains(3)": true},
    {"@@stringSetAccum": [ "World", "There", "Hello" ]},
    {"@@stringSetAccum.contains(Hello)": true},
    {"@@stringSetAccum.size()": 3}
  ]
}
----
--
====


=== BagAccum

The BagAccum type maintains a collection of elements with duplicated elements allowed. The output of a BagAccum is a list of elements in arbitrary order. A BagAccum instance can contain values of one type. The element type can be any base type, tuple, or STRING COMPRESS.

For BagAccum, the *+= arg* operation adds an element or bag of elements to the bag.

BagAccum also supports the *+* operator:

* *@bag1 + @bag2* creates a new BagAccum, which contains the elements of @bag1 and the elements of @bag2. The two BagAccums must have identical data types.

BagAccum also supports the following class functions.

[WARNING]
====
Functions which modify the BagAccum (mutator functions) can be used only under the following conditions:

* Mutator functions of global accumulators may only be used at the query-body level.
* Mutator functions of vertex-attached accumulators may only be used in a POST-ACCUM clause.
====

|===
| Function (T is the element type) | Return type | Accessor / Mutator | Description

| *size()*
| INT
| Accessor
| Returns the number of elements in the bag.

| *contains(* T _value_ *)*
| BOOL
| Accessor
| Returns true/false if the bag does/doesn't contain the _value_ .

| *clear()*
| VOID
| Mutator
| Clears the bag so it becomes empty with size 0.

| *remove(* T _value *)*_
| VOID
| Mutator
| Removes one instance of _value_ from the bag.

| *removeAll(* T _value_ *)*
| VOID
| Mutator
| Removes all instances of the given value from the bag.
|===

==== Example
[tabs]
====
Query::
+
--
.BagAccum Example
[source,gsql]
----
# BagAccum Example
CREATE QUERY bagAccumEx() FOR GRAPH minimalNet {

  #Unordered collection
  BagAccum<INT>    @@intBagAccum;
  BagAccum<STRING> @@stringBagAccum;

  @@intBagAccum += 5;
  @@intBagAccum.clear();

  @@intBagAccum += 4;
  @@intBagAccum += 11;
  @@intBagAccum += 1;
  @@intBagAccum += 11;        #Bag accums can store duplicates
  @@intBagAccum += (1,2,3,4);
  PRINT @@intBagAccum;

  PRINT @@intBagAccum.size();
  PRINT @@intBagAccum.contains(4);

  @@stringBagAccum += "Hello";
  @@stringBagAccum += "Hello";
  @@stringBagAccum += "There";
  @@stringBagAccum += "World";
  PRINT @@stringBagAccum.contains("Hello");
  @@stringBagAccum.remove("Hello");    #Remove one matching element
  @@stringBagAccum.removeAll("There"); #Remove all matching elements
  PRINT @@stringBagAccum;
}
----
--

Results::
+
--
.bagAccumEx.json Result
[source,gsql]
----
GSQL > RUN QUERY bagAccumEx()
{
  "error": false,
  "message": "",
  "version": {
    "edition": "developer",
    "schema": 0,
    "api": "v2"
  },
  "results": [ {"@@intBagAccum": [ 2, 3, 1, 1, 11, 11, 4, 4 ]},
    {"@@intBagAccum.size()": 8},
    {"@@intBagAccum.contains(4)": true},
    {"@@stringBagAccum.contains(Hello)": true},
    {"@@stringBagAccum": [ "World", "Hello" ]}
  ]
}
----
--
====


=== MapAccum

The MapAccum type maintains a collection of (key -> value) pairs. The output of a MapAccum is a set of key and value pairs in which the keys are unique.

The key type of a MapAccum can be all base types or tuples.  If the key type is VERTEX, then only the vertex's id is stored and displayed.

The value type of a MapAccum can be all base types, tuples, or any type of accumulator, except for HeapAccum.

For MapAccum, the *+= `+(key->val)+`* operation adds a key-value element to the collection if *key* is not yet used in the MapAccum. If the MapAccum already contains *key* , then *val* is _accumulated_ to the current value, where the accumulation operation depends on the data type of *val* . (Strings would get concatenated, lists would be appended, numerical values would be added, etc.)

MapAccum also supports the *+* operator:

* *@map1 + @map2* creates a new MapAccum, which contains the (key,value) pairs of @map2 added to the (key,value) pairs of @map1. The two MapAccums must have identical data types.

MapAccum also supports the following class functions.

[WARNING]
====
Functions that modify the MapAccum (mutator functions) can be used only under the following conditions:

* Mutator functions of global accumulators may only be used at the query-body level.
* Mutator functions of vertex-attached accumulators may only be used in a POST-ACCUM clause.
====

|===
| Function (KEY is the key type) | Return type | Accessor / Mutator | Description

| *size()*
| INT
| Accessor
| Returns the number of elements in the map.

| *containsKey(* KEY _key_ *)*
| BOOL
| Accessor
| Returns true/false if the map does/doesn't contain _key_ .

| *get(* KEY _key *)*_
| _value_ type
| Accessor
| Returns the value which the map associates with _key_ . If the map doesn't contain_key_ , then the return value is undefined.

| *clear()*
| VOID
| Mutator
| Clears the map so it becomes empty with size 0.

|`.removeKey( KEY key )`
|`VOID`
|Mutator
| Removes the key-value pair with the specified key. If there is no matching key, then the function will do nothing.
|===

==== Example
[tabs]
====
Query::
+
--
.MapAccum Example
[source,gsql]
----
#MapAccum Example
CREATE QUERY mapAccumEx() FOR GRAPH minimalNet {

  #Map(Key, Value)
  # Keys can be INT or STRING only
  MapAccum<STRING, INT> @@intMapAccum;
  MapAccum<INT, STRING> @@stringMapAccum;
  MapAccum<INT, MapAccum<STRING, STRING>> @@nestedMapAccum;

  @@intMapAccum += ("foo" -> 1);
  @@intMapAccum.clear();

  @@intMapAccum += ("foo" -> 3);
  @@intMapAccum += ("bar" -> 2);
  @@intMapAccum += ("baz" -> 2);
  @@intMapAccum += ("baz" -> 1); #add 1 to existing value

  PRINT @@intMapAccum.containsKey("baz");
  PRINT @@intMapAccum.get("bar");
  PRINT @@intMapAccum.get("root");

  @@stringMapAccum += (1 -> "apple");
  @@stringMapAccum += (2 -> "pear");
  @@stringMapAccum += (3 -> "banana");
  @@stringMapAccum += (4 -> "a");
  @@stringMapAccum += (4 -> "b"); #append "b" to existing value
  @@stringMapAccum += (4 -> "c"); #append "c" to existing value

  PRINT @@intMapAccum;
  PRINT @@stringMapAccum;

  #Checking and getting keys
  if @@stringMapAccum.containsKey(1) THEN
    PRINT @@stringMapAccum.get(1);
  END;

  #Map nesting
  @@nestedMapAccum += ( 1 -> ("foo"  -> "bar") );
  @@nestedMapAccum += ( 1 -> ("flip" -> "top") );
  @@nestedMapAccum += ( 2 -> ("fizz" -> "pop") );
  @@nestedMapAccum += ( 1 -> ("foo"  -> "s") );

  PRINT @@nestedMapAccum;

  if @@nestedMapAccum.containsKey(1) THEN
    if @@nestedMapAccum.get(1).containsKey("foo") THEN
       PRINT @@nestedMapAccum.get(1).get("foo");
    END;
  END;
}
----
--

Results::
+
--
.mapAccumEx.json Result
[source,gsql]
----
GSQL > RUN QUERY mapAccumEx()
{
  "error": false,
  "message": "",
  "version": {
    "edition": "developer",
    "schema": 0,
    "api": "v2"
  },
  "results": [
    {"@@intMapAccum.containsKey(baz)": true},
    {"@@intMapAccum.get(bar)": 2},
    {"@@intMapAccum.get(root)": 0},
    {"@@intMapAccum": {
      "bar": 2,
      "foo": 3,
      "baz": 3
    }},
    {"@@stringMapAccum": {
      "1": "apple",
      "2": "pear",
      "3": "banana",
      "4": "abc"
    }},
    {"@@stringMapAccum.get(1)": "apple"},
    {"@@nestedMapAccum": {
      "1": {
        "foo": "bars",
        "flip": "top"
      },
      "2": {"fizz": "pop"}
    }},
    {"@@nestedMapAccum.get(1).get(foo)": "bars"}
  ]
}
----
--
====


=== ArrayAccum

The ArrayAccum type maintains an array of accumulators. An array is a fixed-length sequence of elements, with direct access to elements by position.  The ArrayAccum has these particular characteristics:

* The elements are accumulators, not primitive or base data types. All accumulators, except HeapAccum, MapAccum, and GroupByAccum, can be used.
* An ArrayAccum instance can be multidimensional. There is no limit to the number of dimensions.
* The size can be set at run-time (dynamically).
* There are operators which update the entire array efficiently.

When an ArrayAccum is declared, the instance name should be followed by a pair of brackets for each dimension.  The brackets may either contain an integer constant to set the size of the array, or they may be empty. In that case, the size must be set with the reallocate function before the ArrayAccum can be used.

.ArrayAccum declaration example
[source,gsql]
----
ArrayAccum<SetAccum<STRING>> @@names[10];
ArrayAccum<SetAccum<INT>> @@ids[][];  // 2-dimensional, size to be determined
----



Because each element of an ArrayAccum itself is an accumulator, the operators =, +=, and + can be used in two contexts: accumulator-level and element-level.

==== *Element-level operations*

If @A is an ArrayAccum of length 6, then @A[0] and @A[5] refer to its first and last elements, respectively. Referring to an ArrayAccum element is like referring to an accumulator of that type.  For example, given the following definitions:

[source,text]
----
ArrayAccum<SumAccum<INT>> @@Sums[3];
ArrayAccum<ListAccum<STRING>> @@Lists[2];
----

then @@Sums[0], @@Sums[1], and @@Sums[2] each refer to an individual SumAccum<INT>, and @@Lists[0] and @@Lists[1] each refer to a ListAccum<STRING>, supporting all the operations for those accumulator and data types.

[source,text]
----
@@Sums[1] = 1;
@@Sums[1] += 2;  // value is now 3
@@Lists[0] = "cat";
@@Lists[0] += "egory";  // value is now "category"
----

==== *Accumulator-level operations*

The operators =, +=, and + have special meanings when applied to an ArrayAccum as a whole. There operations efficiently update an entire ArrayAccum. All of the ArrayAccums must have the same element type.

|===
| Operator | Description | Example

| =
| Sets the ArrayAccum on the left equal to the ArrayAccum on the right. The two ArrayAccums must have the same element type, but the left-side ArrayAccum will change its size and dimensions to match the one on the right side.
| @A = @B;

| +
| Performs element-by-element addition of two ArrayAccums of the same type and size.  The result is a new ArrayAccum of the same size.
| @C = @A + @B;  // @A and @B must be the same size

| +=
| Performs element-by-element accumulation (+=) from the right-side ArrayAccum to the left-side ArrayAccum. They must be the same type and size.
| @A += @B;  // @A and @B must be the same size
|===

ArrayAccum also supports the following class functions.

[WARNING]
====
Functions that modify the ArrayAccum (mutator functions) can be used only under the following conditions:

* Mutator functions of global accumulators may only be used at the query-body level.
* Mutator functions of vertex-attached accumulators may only be used in a POST-ACCUM clause.
====

|===
| Function | Return type | Accessor / Mutator | Description

| *size()*
| INT
| Accessor
| Returns the total number of elements in the (multi-dimensional) array. For example, the size of an ArrayAccum declared as @A[3][4] is 12.

| *reallocate(* INT, ... *)*
| VOID
| Mutator
| Discards the previous ArrayAccum instance and creates a new ArrayAccum, with the size(s) given. An N-dimensional ArrayAccum requires N integer parameters. The reallocate function cannot be used to change the number of dimensions.
|===

==== Example
[tabs]
====
Query::
+
--
.Example of ArrayAccum Element-level Operations
[source,gsql]
----
CREATE QUERY ArrayAccumElem() FOR GRAPH minimalNet {
  	
	ArrayAccum<SumAccum<DOUBLE>> @@aaSumD[2][2];  # 2D Sum Double
	ArrayAccum<SumAccum<STRING>> @@aaSumS[2][2];  # 2D Sum String
	ArrayAccum<MaxAccum<INT>> @@aaMax[2];
	ArrayAccum<MinAccum<UINT>> @@aaMin[2];
	ArrayAccum<AvgAccum> @@aaAvg[2];
	ArrayAccum<AndAccum<BOOL>> @@aaAnd[2];
	ArrayAccum<OrAccum<BOOL>> @@aaOr[2];
	ArrayAccum<BitwiseAndAccum> @@aaBitAnd[2];
	ArrayAccum<BitwiseOrAccum> @@aaBitOr[2];
	ArrayAccum<ListAccum<INT>> @@aaList[2][2];    # 2D List
	ArrayAccum<SetAccum<FLOAT>> @@aaSetF[2];
	ArrayAccum<BagAccum<DATETIME>> @@aaBagT[2];
	
	## for test data	
	ListAccum<STRING> @@words;
	BOOL toggle = false;
	@@words += "1st"; @@words += "2nd"; @@words += "3rd"; @@words += "4th";

	# Int:  a[0] += 1, 2;   a[1] += 3, 4
	# Bool: alternate true/false
	# Float: a[0] += 1.111, 2.222;  a[1] += 3.333, 4.444
	# 2D Doub: a[0][0] += 1.111, 2.222;   a[0][1] += 5.555, 6.666;
	#          a[1][0] += 3.333, 4.444;   a[0][1] += 7.777, 8.888;
	
	FOREACH i IN RANGE [0,1] DO
		FOREACH n IN RANGE [1, 2] DO
			toggle = NOT toggle;
			@@aaMax[i] += i*2 + n;
			@@aaMin[i] += i*2 + n;
			@@aaAvg[i] += i*2 + n;
			@@aaAnd[i] += toggle;
			@@aaOr[i] += toggle;
			@@aaBitAnd[i] += i*2 + n;
			@@aaBitOr[i] += i*2 + n;
			@@aaSetF[i] += (i*2 + n)/0.9;
			@@aaBagT[i] += epoch_to_datetime(i*2 + n);

			FOREACH j IN RANGE [0,1] DO
				@@aaSumD[i][j] += (j*4 + i*2 + n)/0.9;
				@@aaSumS[i][j] += @@words.get((j*2 + i + n)%4);
				@@aaList[i][j] += j*4 +i*2 + n ;
			END;
		END;
	END;
				
	PRINT @@aaSumD;		PRINT @@aaSumS;
	PRINT @@aaMax;		PRINT @@aaMin;		PRINT @@aaAvg;
	PRINT @@aaAnd;		PRINT @@aaOr;
	PRINT @@aaBitAnd;	PRINT @@aaBitOr;
	PRINT @@aaList;		PRINT @@aaSetF;		PRINT @@aaBagT;
}
----
--

Results::
+
--
.ArrayAccumElem.json Results
[source,gsql]
----
GSQL > RUN QUERY ArrayAccumElem()
{
  "error": false,
  "message": "",
  "version": {
    "edition": "developer",
    "schema": 0,
    "api": "v2"
  },
  "results": [
    {"@@aaSumD": [
      [ 3.33333, 12.22222 ],
      [ 7.77778, 16.66667 ]
    ]},
    {"@@aaSumS": [
      [ "2nd3rd", "4th1st" ],
      [ "3rd4th", "1st2nd" ]
    ]},
    {"@@aaMax": [ 2, 4 ]},
    {"@@aaMin": [ 1, 3 ]},
    {"@@aaAvg": [ 1.5, 3.5 ]},
    {"@@aaAnd": [ false, false ]},
    {"@@aaOr": [ true, true ]},
    {"@@aaBitAnd": [ 0, 0 ]},
    {"@@aaBitOr": [ 3, 7]},
    {"@@aaList": [
      [
        [ 1, 2 ],
        [ 5, 6]
      ],
      [
        [ 3, 4 ],
        [ 7, 8 ]
      ]
    ]},
    {"@@aaSetF": [
      [ 2.22222, 1.11111],
      [ 4.44444, 3.33333 ]
    ]},
    {"@@aaBagT": [
      [ 2, 1 ],
      [ 4, 3 ]
    ]}
  ]
}
----
--
====

[tabs]
====
Query::
+
--
.Example of Operations between Whole ArrayAccums
[source,gsql]
----
CREATE QUERY ArrayAccumOp3(INT lenA) FOR GRAPH minimalNet {

	ArrayAccum<SumAccum<INT>> @@arrayA[5]; // Original size
	ArrayAccum<SumAccum<INT>> @@arrayB[2];
	ArrayAccum<SumAccum<INT>> @@arrayC[][]; // No size
	STRING msg;
	@@arrayA.reallocate(lenA);  # Set/Change size dynamically
	@@arrayB.reallocate(lenA+1);
	@@arrayC.reallocate(lenA, lenA+1);

	// Initialize arrays
	FOREACH i IN RANGE[0,lenA-1] DO
		@@arrayA[i] += i*i;
		FOREACH j IN RANGE[0,lenA] DO
			@@arrayC[i][j] += j*10 + i;
		END;
	END;
	FOREACH i IN RANGE[0,lenA] DO
		@@arrayB[i] += 100-i;
	END;
	msg = "Initial Values";
	PRINT msg, @@arrayA, @@arrayB, @@arrayC;

    msg = "Test 1: A = C, C = B";	// = operator
    @@arrayA = @@arrayC;		// change dimensions: 1D <- 2D
    @@arrayC = @@arrayB;		// change dimensions: 2D <- 1D
    PRINT msg, @@arrayA, @@arrayC;

    msg = "Test 2: B += C"; 		// += operator
    @@arrayB += @@arrayC; 		// B and C must have same size & dim
    PRINT msg, @@arrayB, @@arrayC;

    msg = "Test 3: A = B + C"; 		// + operator
    @@arrayA = @@arrayB + @@arrayC; // B & C must have same size & dim
    PRINT msg, @@arrayA; 			// A changes size & dim
}
----
--

Results::
+
--
.ArrayAccumOp3.json Results
[source,gsql]
----
GSQL > RUN QUERY ArrayAccumOp3(3)
{
  "error": false,
  "message": "",
  "version": {
    "edition": "developer",
    "schema": 0,
    "api": "v2"
  },
  "results": [
    {
      "msg": "Initial Values",
      "@@arrayC": [
		[ 0, 10, 20, 30 ],
        [ 1, 11, 21, 31 ],
        [ 2, 12, 22, 32 ]
      ],
      "@@arrayB": [ 100, 99, 98, 97 ],
      "@@arrayA": [ 0, 1, 4 ]
    },
    {
      "msg": "Test 1: A = C, C = B",
      "@@arrayC": [ 100, 99, 98, 97 ],
      "@@arrayA": [
		[ 0, 10, 20, 30 ],
        [ 1, 11, 21, 31 ],
        [ 2, 12, 22, 32 ]
      ]
    },
    {
      "msg": "Test 2: B += C",
      "@@arrayC": [ 100, 99, 98, 97 ],
      "@@arrayB": [ 200, 198,196, 194 ]
    },
    {
      "msg": "Test 3: A = B + C",
      "@@arrayA": [ 300, 297, 294, 291 ]
    }
  ]
}
----
--
====

[tabs]
====
Query::
+
--
.Example for Vertex-Attached ArrayAccum
[source,gsql]
----
CREATE QUERY arrayAccumLocal() FOR GRAPH socialNet api("v2") {
	# Count each person's edges by type
	# friend/liked/posted edges are type 0/1/2, respectively
	ArrayAccum<SumAccum<INT>> @edgesByType[3];
	Persons = {person.*};
	
	Persons = SELECT s
		FROM Persons:s -(:e)-> :t
		ACCUM CASE e.type
			WHEN "friend" THEN s.@edgesByType[0] += 1
			WHEN "liked"  THEN s.@edgesByType[1] += 1
			WHEN "posted" THEN s.@edgesByType[2] += 1
			END
		ORDER BY s.id;
		
	#PRINT Persons.@edgesByType; // api v1
    PRINT Persons[Persons.@edgesByType]; // api v2
}
----
--

Results::
+
--
.Results for Query ArrayAccumLocal
[source,gsql]
----
GSQL > RUN QUERY arrayAccumLocal()
{
  "error": false,
  "message": "",
  "version": {
    "edition": "developer",
    "schema": 0,
    "api": "v2"
  },
  "results": [{"Persons": [
    {
      "v_id": "person1",
      "attributes": {"Persons.@edgesByType": [ 2, 1, 1 ]},
      "v_type": "person"
    },
    {
      "v_id": "person2",
      "attributes": {"Persons.@edgesByType": [ 2, 2, 1 ]},
      "v_type": "person"
    },
    {
      "v_id": "person3",
      "attributes": {"Persons.@edgesByType": [ 2, 1, 1 ]},
      "v_type": "person"
    },
    {
      "v_id": "person4",
      "attributes": {"Persons.@edgesByType": [ 3, 1, 1 ]},
      "v_type": "person"
    },
    {
      "v_id": "person5",
      "attributes": {"Persons.@edgesByType": [ 2, 1, 2 ]},
      "v_type": "person"
    },
    {
      "v_id": "person6",
      "attributes": {"Persons.@edgesByType": [ 2, 1, 2 ]},
      "v_type": "person"
    },
    {
      "v_id": "person7",
      "attributes": {"Persons.@edgesByType": [ 2, 1, 2 ]},
      "v_type": "person"
    },
    {
      "v_id": "person8",
      "attributes": {"Persons.@edgesByType": [ 3, 1, 2 ]},
      "v_type": "person"
    }
  ]}]
}
----
--
====


=== HeapAccum

The HeapAccum type maintains a sorted collection of tuples and enforces a maximum number of tuples in the collection.
The output of a HeapAccum is a sorted collection of tuple elements.
The `+=` operation adds a tuple to the collection in sorted order. If the HeapAccum is already at maximum capacity when the `+=` operator is applied, then the tuple which is last in the sorted order is dropped from the HeapAccum.
Sorting of tuples is performed on one or more defined tuple fields ordered either ascending or descending.
Sorting precedence is performed based on defined tuple fields from left to right.

You must have defined a custom xref:data-types.adoc#_tuple[tuple type] to declare a `HeapAccum`, and one of the fields in the tuple must be a data type that can be sorted.

The declaration syntax is outlined in the figure below:

.HeapAccum declaration syntax
[source,ebnf]
----
HeapAccum<tupleType>( [capacity], field_a [ASC|DESC],... , field_z [ASC|DESC]);
----

In the declaration of the `HeapAccum`, the keyword `HeapAccum` is followed by the tuple type in angle brackets `< >`.
This is followed by a parenthesized list of two or more parameters.

* If the first parameter is a positive integer, it sets the maximum number of tuples that the HeapAccum may store.
* The subsequent parameters are a subset of the tuple's field, which are used as sort keys.
The sort key hierarchy is from left to right, with the leftmost key being the primary sort key.
The keywords `ASC` and `DESC` indicate Ascending (lowest value first) or Descending (highest value first) sort order.
Ascending order is the default.

==== Functions
HeapAccum also supports the following class functions.

[WARNING]
====
Functions that modify the `HeapAccum` (mutator functions) can be used only under the following conditions:

* Mutator functions of global accumulators may only be used at the query-body level.
* Mutator functions of vertex-attached accumulators may only be used in a POST-ACCUM clause.
====

|===
| Function | Return type | Accessor / Mutator | Description

| *size()*
| INT
| Accessor
| Returns the number of elements in the heap.

| *top()*
| tupleType
| Accessor
| Returns the top tuple. If this heap is empty, returns a tuple with each element equal to the default value.

| *pop()*
| tupleType
| Mutator
| Returns the top tuple and removes it from the heap. If this heap is empty, returns a tuple with each element equal to the default value.

| *resize(* INT *)*
| VOID
| Mutator
| Changes the maximum capacity of the heap.

| *clear()*
| VOID
| Mutator
| Clears the heap so it becomes empty with size 0.
|===

==== Example
[tabs]
====
Query::
+
--
.HeapAccum Example
[source,gsql]
----
#HeapAccum Example
CREATE QUERY heapAccumEx() FOR GRAPH minimalNet {
  TYPEDEF tuple<STRING firstName, STRING lastName, INT score> testResults;

  #Heap with max size of 4 sorted decending by score then ascending last name
  HeapAccum<testResults>(4, score DESC, lastName ASC) @@topTestResults;

  PRINT @@topTestResults.top();

  @@topTestResults += testResults("Bruce", "Wayne", 80);
  @@topTestResults += testResults("Peter", "Parker", 80);
  @@topTestResults += testResults("Tony", "Stark", 100);
  @@topTestResults += testResults("Bruce", "Banner", 95);
  @@topTestResults += testResults("Jean", "Summers", 95);
  @@topTestResults += testResults("Clark", "Kent", 80);

  #Show element with the highest sorted position
  PRINT @@topTestResults.top();
  PRINT @@topTestResults.top().firstName, @@topTestResults.top().lastName, @@topTestResults.top().score;

  PRINT @@topTestResults;

  #Increase the size of the heap to add more elements
  @@topTestResults.resize(5);

  #Find the size of the current heap
  PRINT @@topTestResults.size();

  @@topTestResults += testResults("Bruce", "Wayne", 80);
  @@topTestResults += testResults("Peter", "Parker", 80);

  PRINT @@topTestResults;

  #Resizing smaller WILL REMOVE excess elements from the HeapAccum
  @@topTestResults.resize(3);
  PRINT @@topTestResults;

  #Increasing capacity will not restore dropped elements
  @@topTestResults.resize(5);
  PRINT @@topTestResults;

  #Removes all elements from the HeapAccum
  @@topTestResults.clear();
  PRINT @@topTestResults.size();
}
----
--

Results::
+
--
.heapAccumEx.json Results
[source,gsql]
----
GSQL > RUN QUERY heapAccumEx()
{
  "error": false,
  "message": "",
  "version": {
    "edition": "developer",
    "schema": 0,
    "api": "v2"
  },
  "results": [
    {"@@topTestResults.top()": {
      "firstName": "",
      "lastName": "",
      "score": 0
    }},
    {"@@topTestResults.top()": {
      "firstName": "Tony",
      "lastName": "Stark",
      "score": 100
    }},
    {
      "@@topTestResults.top().firstName": "Tony",
      "@@topTestResults.top().lastName": "Stark",
      "@@topTestResults.top().score": 100
    },
    {"@@topTestResults": [
      {
        "firstName": "Tony",
        "lastName": "Stark",
        "score": 100
      },
      {
        "firstName": "Bruce",
        "lastName": "Banner",
        "score": 95
      },
      {
        "firstName": "Jean",
        "lastName": "Summers",
        "score": 95
      },
      {
        "firstName": "Clark",
        "lastName": "Kent",
        "score": 80
      }
    ]},
    {"@@topTestResults.size()": 4},
    {"@@topTestResults": [
      {
        "firstName": "Tony",
        "lastName": "Stark",
        "score": 100
      },
      {
        "firstName": "Bruce",
        "lastName": "Banner",
        "score": 95
      },
      {
        "firstName": "Jean",
        "lastName": "Summers",
        "score": 95
      },
      {
        "firstName": "Clark",
        "lastName": "Kent",
        "score": 80
      },
      {
        "firstName": "Peter",
        "lastName": "Parker",
        "score": 80
      }
    ]},
    {"@@topTestResults": [
      {
        "firstName": "Tony",
        "lastName": "Stark",
        "score": 100
      },
      {
        "firstName": "Bruce",
        "lastName": "Banner",
        "score": 95
      },
      {
        "firstName": "Jean",
        "lastName": "Summers",
        "score": 95
      }
    ]},
    {"@@topTestResults": [
      {
        "firstName": "Tony",
        "lastName": "Stark",
        "score": 100
      },
      {
        "firstName": "Bruce",
        "lastName": "Banner",
        "score": 95
      },
      {
        "firstName": "Jean",
        "lastName": "Summers",
        "score": 95
      }
    ]},
    {"@@topTestResults.size()": 0}
  ]
}
----
--
====


=== GroupByAccum

The GroupByAccum is a compound accumulator, an accumulator of accumulators. At the top level, it is a MapAccum where both the key and the value can have multiple fields. Moreover, each of the value fields is an accumulator type.

.GroupByAccum syntax
[source,ebnf]
----
GroupByAccum<type [, type]* , accumType [, accumType]* >
----



In the EBNF above, the *type* terms form the key set, and the *accumType* terms form the map's value. Since they are accumulators, they perform a grouping. Like a MapAccum, if we try to store a (key->value) whose key has already been used, then the new value will accumulate to the data which is already stored.  In this case, each field of the multiple-field value has its own accumulation function. One way to think about GroupByAccum is that each unique key is a group ID.

In GroupByAccum, the key types can be base type, tuple, or STRING COMPRESS. The accumulators are used for aggregating group values.  Each accumulator type can be any type including HeapAccum. Each base type and each accumulator type must be followed an alias. Below is an example declaration.

[source,text]
----

Typedef tuple <id int, name string, age int> myTuple;
Typedef HeapAccum <myTuple> (2, name desc, age desc, id asc) myHeap;
GroupByAccum<INT a, STRING b,
             MaxAccum<INT> maxa,
             ListAccum<ListAccum<INT>> lists,
             myHeap h> @@group;
----

To add new data to this GroupByAccum, the data should be formatted as *(key1, key2 -> value1, value2)* .

GroupByAccum also supports the following class functions.

[WARNING]
====
Functions that modify the GroupByAccum (mutator functions) can be used only under the following conditions:

* Mutator functions of global accumulators may only be used at the query-body level.
* Mutator functions of vertex-attached accumulators may only be used in a POST-ACCUM clause.
====

|===
| Function (KEY1..KEYn are the key types) | Return type | Accessor / Mutator | Description

| *size()*
| INT
| Accessor
| Returns the number of elements in the heap.

| *get(* KEY1 _key_value1_ , KEY2 _key_value2_ ... )
| element type(s) of the accumulator(s)
| Accessor
| Returns the values from each accumulator in the group associating with the given key(s). If the key(s) doesn't exist, return the default value(s) of the accumulator type(s).

| *containsKey(* KEY1 _key_value1_ , KEY2 _key_value2_... *)*
| BOOL
| Accessor
| Returns true/false if the accumulator contains the key(s)

| *clear()*
| VOID
| Mutator
| Clears the heap so it becomes empty with size 0.

| *remove* ( KEY1 _key_value1_ , KEY2 _key_value2_ ... *)*
| VOID
| Mutator
| Removes the group associating with the key(s)
|===

==== Example
[tabs]
====
Query::
+
--
.GroupByAccum Example
[source,gsql]
----
#GroupByAccum Example
CREATE QUERY groupByAccumEx () FOR GRAPH socialNet {
  ##declare HeapAccum type and tuple used in the HeapAccum
  Typedef tuple <id int, name string, age int> myTuple;
  Typedef HeapAccum <myTuple> (2, name desc, age desc, id asc) myHeap;
  ## declaration, first two primitive type are group by keys; the rest accumulator type are aggregates
  GroupByAccum<INT a, STRING b, MaxAccum<INT> maxa, ListAccum<ListAccum<INT>> lists> @@group;
  GroupByAccum<STRING gender, MapAccum<VERTEX<person>, DATETIME> m> @@group2;
  GroupByAccum<INT age, myHeap h> @@group4;
  # nested GroupByAccum
  GroupByAccum<INT a, MaxAccum<INT> maxa, GroupByAccum<INT a, MaxAccum<INT> maxa> heap> @@group3;
  Start = { person.* };

  ## usage of global GroupByAccum
  @@group += (1, "a" -> 1, [1]);
  @@group += (1, "a" -> 2, [2]);
  @@group += (2, "b" -> 1, [4]);

  @@group3 += (2 -> 1, (2 -> 0) );
  @@group3 += (2 -> 1, (2 -> 5) );
  @@group3 += (2 -> 5, (3 -> 3) );
  PRINT @@group, @@group.get(1, "a"), @@group.get(1, "a").lists,  @@group.containsKey(1, "c"), @@group3;

  ## HeapAccum inside GroupByAccum
  @@group4 += (29->myTuple(1,"aaa", 18));
  @@group4 += (29->myTuple(2,"bbb", 19));
  @@group4 += (29->myTuple(3,"ccc", 20));
  PRINT @@group4;

  ## two kinds of foreach
  FOREACH g IN @@group DO
    PRINT g.a, g.b, g.maxa, g.lists;
  END;
  FOREACH (g1,g2,g3,g4) IN @@group DO
    PRINT g1,g2,g3,g4;
  END;

  S = SELECT v
      FROM Start:v - (liked:e) - post:t
      ACCUM @@group2 += (v.gender -> (v -> e.actionTime));

  PRINT @@group2, @@group2.get("Male").m, @@group2.get("Female").m;
}
----
--

Results::
+
--
.Result for Query groupByAccum
[source,gsql]
----
GSQL > RUN QUERY groupByAccumEx()
{
  "error": false,
  "message": "",
  "version": {
    "edition": "developer",
    "schema": 0,
    "api": "v2"
  },
  "results": [
    {
      "@@group.get(1,a).lists": [
        [1],
        [2]
      ],
      "@@group3": [{
        "a": 2,
        "heap": [
          {
            "a": 3,
            "maxa": 3
          },
          {
            "a": 2,
            "maxa": 5
          }
        ],
        "maxa": 5
      }],
      "@@group.containsKey(1,c)": false,
      "@@group.get(1,a)": {
        "lists": [
          [1],
          [2]
        ],
        "maxa": 2
      },
      "@@group": [
        {
          "a": 2,
          "b": "b",
          "lists": [[4]],
          "maxa": 1
        },
        {
          "a": 1,
          "b": "a",
          "lists": [
            [1],
            [2]
          ],
          "maxa": 2
        }
      ]
    },
    {
      "g.b": "b",
      "g.maxa": 1,
      "g.lists": [[4]],
      "g.a": 2
    },
    {
      "g.b": "a",
      "g.maxa": 2,
      "g.lists": [
        [1],
        [2]
      ],
      "g.a": 1
    },
    {
      "g1": 2,
      "g2": "b",
      "g3": 1,
      "g4": [[4]]
    },
    {
      "g1": 1,
      "g2": "a",
      "g3": 2,
      "g4": [
        [1],
        [2]
      ]
    },
    {
      "@@group2.get(Male).m": {
        "person3": 1263618953,
        "person1": 1263209520,
        "person8": 1263180365,
        "person7": 1263295325,
        "person6": 1263468185
      },
      "@@group2": [
        {
          "gender": "Male",
          "m": {
            "person3": 1263618953,
            "person1": 1263209520,
            "person8": 1263180365,
            "person7": 1263295325,
            "person6": 1263468185
          }
        },
        {
          "gender": "Female",
          "m": {
            "person4": 1263352565,
            "person2": 2526519281,
            "person5": 1263330725
          }
        }
      ],
      "@@group2.get(Female).m": {
        "person4": 1263352565,
        "person2": 2526519281,
        "person5": 1263330725
      }
    }
  ]
}
----
--
====


== Nested Accumulators

Certain collection accumulators may be nested. That is, an accumulator may contain a collection of elements where the elements themselves are accumulators. For example:

[source,text]
----
ListAccum<ListAccum<INT>> @@matrix; # a 2-dimensional jagged array of integers.  Each inner list has its own unique size.
----

Only ListAccum, ArrayAccum, MapAccum, and GroupByAccum can contain other accumulators. However, not all combinations of collection accumulators are allowed. The following constraints apply:

. ListAccum: ListAccum is the only accumulator type that can be nested within ListAccum, up to a depth of 3:

[source,text]
----
ListAccum<ListAccum<INT>>
ListAccum<ListAccum<ListAccum<INT>>>
ListAccum<SetAccum<INT>> # illegal
----

. MapAccum: All accumulator types, except for HeapAccum, can be nested within MapAccum as the value type. For example,

[source,text]
----
MapAccum<STRING, ListAccum<INT>>
MapAccum<INT, MapAccum<INT, STRING>>
MapAccum<VERTEX, SumAccum<INT>>
MapAccum<STRING, SetAccum<VERTEX>>
MapAccum<STRING, GroupByAccum<VERTEX a, MaxAccum<INT> maxs>>
MapAccum<SetAccum<INT>, INT> # illegal
----

. GroupByAccum: All accumulator types, except for HeapAccum, can be nested within GroupByAccum as the accumulator type. For example:

[source,text]
----
GroupByAccum<INT a, STRING b, MaxAccum<INT> maxs, ListAccum<ListAccum<INT>> lists>
----

. ArrayAccum: Unlike the other accumulators in this list, where nesting is optional, nesting is mandatory for ArrayAccum. See the xref:querying:accumulators.adoc#_arrayaccum[ArrayAccum] section.

It is legal to define nested ListAccums to form a multi-dimensional array. Note the declaration statements and the nested [ bracket ] notation in the example below:

[tabs]
====
Query::
+
--
[source,text]
----
CREATE QUERY nestedAccumEx() FOR GRAPH minimalNet {
  ListAccum<ListAccum<INT>> @@_2d_list;
  ListAccum<ListAccum<ListAccum<INT>>> @@_3d_list;
  ListAccum<INT> @@_1d_list;
  SumAccum <INT> @@sum = 4;

  @@_1d_list += 1;
  @@_1d_list += 2;
  // add 1D-list to 2D-list as element
  @@_2d_list += @@_1d_list;

  // add 1D-enum-list to 2D-list as element
  @@_2d_list += [@@sum, 5, 6];
  // combine 2D-enum-list and 2d-list
  @@_2d_list += [[7, 8, 9], [10, 11], [12]];

  // add an empty 1D-list
  @@_1d_list.clear();
  @@_2d_list += @@_1d_list;

  // combine two 2D-list
  @@_2d_list += @@_2d_list;

  PRINT @@_2d_list;

  // test 3D-list
  @@_3d_list += @@_2d_list;
  @@_3d_list += [[7, 8, 9], [10, 11], [12]];
  PRINT @@_3d_list;
}
----
--
Results::
+
--
.nestedAccumEx.json Results
[source,gsql]
----
GSQL > RUN QUERY nestedAccumEx()
{
  "error": false,
  "message": "",
  "version": {
    "edition": "developer",
    "schema": 0,
    "api": "v2"
  },
  "results": [
    {"@@_2d_list": [
      [1,2],
      [4,5,6],
      [7,8,9],
      [10,11],
      [12],
      [],
      [1,2],
      [4,5,6],
      [7,8,9],
      [10,11],
      [12],
      []
    ]},
    {"@@_3d_list": [
      [
        [1,2],
        [4,5,6],
        [7,8,9],
        [10,11],
        [12],
        [],
        [1,2],
        [4,5,6],
        [7,8,9],
        [10,11],
        [12],
        []
      ],
      [
        [7,8,9],
        [10,11],
        [12]
      ]
    ]}
  ]
}
----
--
====

